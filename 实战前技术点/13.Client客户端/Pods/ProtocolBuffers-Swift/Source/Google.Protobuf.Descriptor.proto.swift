// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "descriptor.proto"
// Syntax "Proto2"

import Foundation

public struct Google { public struct Protobuf { }}

public extension Google.Protobuf {
  public struct DescriptorRoot {
    public static let `default` = DescriptorRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
  }

  // The protocol compiler can output a FileDescriptorSet containing the .proto
  // files it parses.
  final public class FileDescriptorSet : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.FileDescriptorSet, rhs: Google.Protobuf.FileDescriptorSet) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.file == rhs.file)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var file:Array<Google.Protobuf.FileDescriptorProto>  = Array<Google.Protobuf.FileDescriptorProto>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitFile:Bool = true
      for oneElementFile in file {
        if !oneElementFile.isInitialized() {
          isInitFile = false
          break 
        }
      }
      if !isInitFile {
        return isInitFile
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      for oneElementFile in file {
          try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementFile)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementFile in file {
          serialize_size += oneElementFile.computeMessageSize(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.FileDescriptorSet.Builder {
      return Google.Protobuf.FileDescriptorSet.classBuilder() as! Google.Protobuf.FileDescriptorSet.Builder
    }
    public func getBuilder() -> Google.Protobuf.FileDescriptorSet.Builder {
      return classBuilder() as! Google.Protobuf.FileDescriptorSet.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.FileDescriptorSet.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.FileDescriptorSet.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.FileDescriptorSet.Builder {
      return try Google.Protobuf.FileDescriptorSet.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.FileDescriptorSet) throws -> Google.Protobuf.FileDescriptorSet.Builder {
      return try Google.Protobuf.FileDescriptorSet.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !file.isEmpty {
        var jsonArrayFile:Array<Dictionary<String,Any>> = []
          for oneValueFile in file {
            let ecodedMessageFile = try oneValueFile.encode()
            jsonArrayFile.append(ecodedMessageFile)
          }
        jsonMap["file"] = jsonArrayFile
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.FileDescriptorSet {
      return try Google.Protobuf.FileDescriptorSet.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.FileDescriptorSet {
      return try Google.Protobuf.FileDescriptorSet.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var fileElementIndex:Int = 0
      for oneElementFile in file {
          output += "\(indent) file[\(fileElementIndex)] {\n"
          output += try oneElementFile.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          fileElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementFile in file {
                hashCode = (hashCode &* 31) &+ oneElementFile.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.FileDescriptorSet"
    }
    override public func className() -> String {
        return "Google.Protobuf.FileDescriptorSet"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.FileDescriptorSet = Google.Protobuf.FileDescriptorSet()
      public func getMessage() -> Google.Protobuf.FileDescriptorSet {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var file:Array<Google.Protobuf.FileDescriptorProto> {
           get {
               return builderResult.file
           }
           set (value) {
               builderResult.file = value
           }
      }
      @discardableResult
      public func setFile(_ value:Array<Google.Protobuf.FileDescriptorProto>) -> Google.Protobuf.FileDescriptorSet.Builder {
        self.file = value
        return self
      }
      @discardableResult
      public func clearFile() -> Google.Protobuf.FileDescriptorSet.Builder {
        builderResult.file.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.FileDescriptorSet.Builder {
        builderResult = Google.Protobuf.FileDescriptorSet()
        return self
      }
      override public func clone() throws -> Google.Protobuf.FileDescriptorSet.Builder {
        return try Google.Protobuf.FileDescriptorSet.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.FileDescriptorSet {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.FileDescriptorSet {
        let returnMe:Google.Protobuf.FileDescriptorSet = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.FileDescriptorSet) throws -> Google.Protobuf.FileDescriptorSet.Builder {
        if other == Google.Protobuf.FileDescriptorSet() {
         return self
        }
        if !other.file.isEmpty  {
           builderResult.file += other.file
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.FileDescriptorSet.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorSet.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Google.Protobuf.FileDescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            file.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.FileDescriptorSet.Builder {
        let resultDecodedBuilder = Google.Protobuf.FileDescriptorSet.Builder()
        if let jsonValueFile = jsonMap["file"] as? Array<Dictionary<String,Any>> {
          var jsonArrayFile:Array<Google.Protobuf.FileDescriptorProto> = []
          for oneValueFile in jsonValueFile {
            let messageFromStringFile = try Google.Protobuf.FileDescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueFile).build()

            jsonArrayFile.append(messageFromStringFile)
          }
          resultDecodedBuilder.file = jsonArrayFile
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.FileDescriptorSet.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.FileDescriptorSet.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // Describes a complete .proto file.
  final public class FileDescriptorProto : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.FileDescriptorProto, rhs: Google.Protobuf.FileDescriptorProto) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
      fieldCheck = fieldCheck && (lhs.hasPackage == rhs.hasPackage) && (!lhs.hasPackage || lhs.package == rhs.package)
      fieldCheck = fieldCheck && (lhs.dependency == rhs.dependency)
      fieldCheck = fieldCheck && (lhs.messageType == rhs.messageType)
      fieldCheck = fieldCheck && (lhs.enumType == rhs.enumType)
      fieldCheck = fieldCheck && (lhs.service == rhs.service)
      fieldCheck = fieldCheck && (lhs.`extension` == rhs.`extension`)
      fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
      fieldCheck = fieldCheck && (lhs.hasSourceCodeInfo == rhs.hasSourceCodeInfo) && (!lhs.hasSourceCodeInfo || lhs.sourceCodeInfo == rhs.sourceCodeInfo)
      fieldCheck = fieldCheck && (lhs.publicDependency == rhs.publicDependency)
      fieldCheck = fieldCheck && (lhs.weakDependency == rhs.weakDependency)
      fieldCheck = fieldCheck && (lhs.hasSyntax == rhs.hasSyntax) && (!lhs.hasSyntax || lhs.syntax == rhs.syntax)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    // file name, relative to root of source tree
    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    // e.g. "foo", "foo.bar", etc.
    public fileprivate(set) var package:String = ""
    public fileprivate(set) var hasPackage:Bool = false

    // Names of files imported by this file.
    public fileprivate(set) var dependency:Array<String> = Array<String>()
    // Indexes of the public imported files in the dependency list above.
    public fileprivate(set) var publicDependency:Array<Int32> = Array<Int32>()
    // Indexes of the weak imported files in the dependency list.
    // For Google-internal migration only. Do not use.
    public fileprivate(set) var weakDependency:Array<Int32> = Array<Int32>()
    public fileprivate(set) var messageType:Array<Google.Protobuf.DescriptorProto>  = Array<Google.Protobuf.DescriptorProto>()
    public fileprivate(set) var enumType:Array<Google.Protobuf.EnumDescriptorProto>  = Array<Google.Protobuf.EnumDescriptorProto>()
    public fileprivate(set) var service:Array<Google.Protobuf.ServiceDescriptorProto>  = Array<Google.Protobuf.ServiceDescriptorProto>()
    public fileprivate(set) var `extension`:Array<Google.Protobuf.FieldDescriptorProto>  = Array<Google.Protobuf.FieldDescriptorProto>()
    public fileprivate(set) var options:Google.Protobuf.FileOptions!
    public fileprivate(set) var hasOptions:Bool = false
    public fileprivate(set) var sourceCodeInfo:Google.Protobuf.SourceCodeInfo!
    public fileprivate(set) var hasSourceCodeInfo:Bool = false
    // The syntax of the proto file.
    // The supported values are "proto2" and "proto3".
    public fileprivate(set) var syntax:String = ""
    public fileprivate(set) var hasSyntax:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitMessageType:Bool = true
      for oneElementMessageType in messageType {
        if !oneElementMessageType.isInitialized() {
          isInitMessageType = false
          break 
        }
      }
      if !isInitMessageType {
        return isInitMessageType
      }
      var isInitEnumType:Bool = true
      for oneElementEnumType in enumType {
        if !oneElementEnumType.isInitialized() {
          isInitEnumType = false
          break 
        }
      }
      if !isInitEnumType {
        return isInitEnumType
      }
      var isInitService:Bool = true
      for oneElementService in service {
        if !oneElementService.isInitialized() {
          isInitService = false
          break 
        }
      }
      if !isInitService {
        return isInitService
      }
      var isInitExtension:Bool = true
      for oneElementExtension in `extension` {
        if !oneElementExtension.isInitialized() {
          isInitExtension = false
          break 
        }
      }
      if !isInitExtension {
        return isInitExtension
      }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasName {
        try codedOutputStream.writeString(fieldNumber: 1, value:name)
      }
      if hasPackage {
        try codedOutputStream.writeString(fieldNumber: 2, value:package)
      }
      if !dependency.isEmpty {
        for oneValuedependency in dependency {
          try codedOutputStream.writeString(fieldNumber: 3, value:oneValuedependency)
        }
      }
      for oneElementMessageType in messageType {
          try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementMessageType)
      }
      for oneElementEnumType in enumType {
          try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementEnumType)
      }
      for oneElementService in service {
          try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementService)
      }
      for oneElementExtension in `extension` {
          try codedOutputStream.writeMessage(fieldNumber: 7, value:oneElementExtension)
      }
      if hasOptions {
        try codedOutputStream.writeMessage(fieldNumber: 8, value:options)
      }
      if hasSourceCodeInfo {
        try codedOutputStream.writeMessage(fieldNumber: 9, value:sourceCodeInfo)
      }
      if !publicDependency.isEmpty {
        for oneValuepublicDependency in publicDependency {
          try codedOutputStream.writeInt32(fieldNumber: 10, value:oneValuepublicDependency)
        }
      }
      if !weakDependency.isEmpty {
        for oneValueweakDependency in weakDependency {
          try codedOutputStream.writeInt32(fieldNumber: 11, value:oneValueweakDependency)
        }
      }
      if hasSyntax {
        try codedOutputStream.writeString(fieldNumber: 12, value:syntax)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(fieldNumber: 1)
      }
      if hasPackage {
        serialize_size += package.computeStringSize(fieldNumber: 2)
      }
      var dataSizeDependency:Int32 = 0
      for oneValuedependency in dependency {
          dataSizeDependency += oneValuedependency.computeStringSizeNoTag()
      }
      serialize_size += dataSizeDependency
      serialize_size += 1 * Int32(dependency.count)
      for oneElementMessageType in messageType {
          serialize_size += oneElementMessageType.computeMessageSize(fieldNumber: 4)
      }
      for oneElementEnumType in enumType {
          serialize_size += oneElementEnumType.computeMessageSize(fieldNumber: 5)
      }
      for oneElementService in service {
          serialize_size += oneElementService.computeMessageSize(fieldNumber: 6)
      }
      for oneElementExtension in `extension` {
          serialize_size += oneElementExtension.computeMessageSize(fieldNumber: 7)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(fieldNumber: 8) {
              serialize_size += varSizeoptions
          }
      }
      if hasSourceCodeInfo {
          if let varSizesourceCodeInfo = sourceCodeInfo?.computeMessageSize(fieldNumber: 9) {
              serialize_size += varSizesourceCodeInfo
          }
      }
      var dataSizePublicDependency:Int32 = 0
      for oneValuepublicDependency in publicDependency {
          dataSizePublicDependency += oneValuepublicDependency.computeInt32SizeNoTag()
      }
      serialize_size += dataSizePublicDependency
      serialize_size += 1 * Int32(publicDependency.count)
      var dataSizeWeakDependency:Int32 = 0
      for oneValueweakDependency in weakDependency {
          dataSizeWeakDependency += oneValueweakDependency.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeWeakDependency
      serialize_size += 1 * Int32(weakDependency.count)
      if hasSyntax {
        serialize_size += syntax.computeStringSize(fieldNumber: 12)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.FileDescriptorProto.Builder {
      return Google.Protobuf.FileDescriptorProto.classBuilder() as! Google.Protobuf.FileDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.FileDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.FileDescriptorProto.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.FileDescriptorProto.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.FileDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.FileDescriptorProto.Builder {
      return try Google.Protobuf.FileDescriptorProto.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.FileDescriptorProto) throws -> Google.Protobuf.FileDescriptorProto.Builder {
      return try Google.Protobuf.FileDescriptorProto.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasName {
        jsonMap["name"] = name
      }
      if hasPackage {
        jsonMap["package"] = package
      }
      if !dependency.isEmpty {
        var jsonArrayDependency:Array<String> = []
          for oneValueDependency in dependency {
            jsonArrayDependency.append(oneValueDependency)
          }
        jsonMap["dependency"] = jsonArrayDependency
      }
      if !publicDependency.isEmpty {
        var jsonArrayPublicDependency:Array<Int> = []
          for oneValuePublicDependency in publicDependency {
            jsonArrayPublicDependency.append(Int(oneValuePublicDependency))
          }
        jsonMap["publicDependency"] = jsonArrayPublicDependency
      }
      if !weakDependency.isEmpty {
        var jsonArrayWeakDependency:Array<Int> = []
          for oneValueWeakDependency in weakDependency {
            jsonArrayWeakDependency.append(Int(oneValueWeakDependency))
          }
        jsonMap["weakDependency"] = jsonArrayWeakDependency
      }
      if !messageType.isEmpty {
        var jsonArrayMessageType:Array<Dictionary<String,Any>> = []
          for oneValueMessageType in messageType {
            let ecodedMessageMessageType = try oneValueMessageType.encode()
            jsonArrayMessageType.append(ecodedMessageMessageType)
          }
        jsonMap["messageType"] = jsonArrayMessageType
      }
      if !enumType.isEmpty {
        var jsonArrayEnumType:Array<Dictionary<String,Any>> = []
          for oneValueEnumType in enumType {
            let ecodedMessageEnumType = try oneValueEnumType.encode()
            jsonArrayEnumType.append(ecodedMessageEnumType)
          }
        jsonMap["enumType"] = jsonArrayEnumType
      }
      if !service.isEmpty {
        var jsonArrayService:Array<Dictionary<String,Any>> = []
          for oneValueService in service {
            let ecodedMessageService = try oneValueService.encode()
            jsonArrayService.append(ecodedMessageService)
          }
        jsonMap["service"] = jsonArrayService
      }
      if !`extension`.isEmpty {
        var jsonArrayExtension:Array<Dictionary<String,Any>> = []
          for oneValueExtension in `extension` {
            let ecodedMessageExtension = try oneValueExtension.encode()
            jsonArrayExtension.append(ecodedMessageExtension)
          }
        jsonMap["extension"] = jsonArrayExtension
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      if hasSourceCodeInfo {
        jsonMap["sourceCodeInfo"] = try sourceCodeInfo.encode()
      }
      if hasSyntax {
        jsonMap["syntax"] = syntax
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.FileDescriptorProto {
      return try Google.Protobuf.FileDescriptorProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.FileDescriptorProto {
      return try Google.Protobuf.FileDescriptorProto.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasPackage {
        output += "\(indent) package: \(package) \n"
      }
      var dependencyElementIndex:Int = 0
      for oneValueDependency in dependency  {
          output += "\(indent) dependency[\(dependencyElementIndex)]: \(oneValueDependency)\n"
          dependencyElementIndex += 1
      }
      var messageTypeElementIndex:Int = 0
      for oneElementMessageType in messageType {
          output += "\(indent) messageType[\(messageTypeElementIndex)] {\n"
          output += try oneElementMessageType.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          messageTypeElementIndex += 1
      }
      var enumTypeElementIndex:Int = 0
      for oneElementEnumType in enumType {
          output += "\(indent) enumType[\(enumTypeElementIndex)] {\n"
          output += try oneElementEnumType.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          enumTypeElementIndex += 1
      }
      var serviceElementIndex:Int = 0
      for oneElementService in service {
          output += "\(indent) service[\(serviceElementIndex)] {\n"
          output += try oneElementService.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          serviceElementIndex += 1
      }
      var extensionElementIndex:Int = 0
      for oneElementExtension in `extension` {
          output += "\(indent) extension[\(extensionElementIndex)] {\n"
          output += try oneElementExtension.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          extensionElementIndex += 1
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasSourceCodeInfo {
        output += "\(indent) sourceCodeInfo {\n"
        if let outDescSourceCodeInfo = sourceCodeInfo {
          output += try outDescSourceCodeInfo.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      var publicDependencyElementIndex:Int = 0
      for oneValuePublicDependency in publicDependency  {
          output += "\(indent) publicDependency[\(publicDependencyElementIndex)]: \(oneValuePublicDependency)\n"
          publicDependencyElementIndex += 1
      }
      var weakDependencyElementIndex:Int = 0
      for oneValueWeakDependency in weakDependency  {
          output += "\(indent) weakDependency[\(weakDependencyElementIndex)]: \(oneValueWeakDependency)\n"
          weakDependencyElementIndex += 1
      }
      if hasSyntax {
        output += "\(indent) syntax: \(syntax) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasPackage {
               hashCode = (hashCode &* 31) &+ package.hashValue
            }
            for oneValueDependency in dependency {
                hashCode = (hashCode &* 31) &+ oneValueDependency.hashValue
            }
            for oneElementMessageType in messageType {
                hashCode = (hashCode &* 31) &+ oneElementMessageType.hashValue
            }
            for oneElementEnumType in enumType {
                hashCode = (hashCode &* 31) &+ oneElementEnumType.hashValue
            }
            for oneElementService in service {
                hashCode = (hashCode &* 31) &+ oneElementService.hashValue
            }
            for oneElementExtension in `extension` {
                hashCode = (hashCode &* 31) &+ oneElementExtension.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            if hasSourceCodeInfo {
                if let hashValuesourceCodeInfo = sourceCodeInfo?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuesourceCodeInfo
                }
            }
            for oneValuePublicDependency in publicDependency {
                hashCode = (hashCode &* 31) &+ oneValuePublicDependency.hashValue
            }
            for oneValueWeakDependency in weakDependency {
                hashCode = (hashCode &* 31) &+ oneValueWeakDependency.hashValue
            }
            if hasSyntax {
               hashCode = (hashCode &* 31) &+ syntax.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.FileDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.FileDescriptorProto"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.FileDescriptorProto = Google.Protobuf.FileDescriptorProto()
      public func getMessage() -> Google.Protobuf.FileDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      @discardableResult
      public func setName(_ value:String) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.name = value
        return self
      }
      @discardableResult
      public func clearName() -> Google.Protobuf.FileDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var hasPackage:Bool {
           get {
                return builderResult.hasPackage
           }
      }
      public var package:String {
           get {
                return builderResult.package
           }
           set (value) {
               builderResult.hasPackage = true
               builderResult.package = value
           }
      }
      @discardableResult
      public func setPackage(_ value:String) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.package = value
        return self
      }
      @discardableResult
      public func clearPackage() -> Google.Protobuf.FileDescriptorProto.Builder{
           builderResult.hasPackage = false
           builderResult.package = ""
           return self
      }
      public var dependency:Array<String> {
           get {
               return builderResult.dependency
           }
           set (array) {
               builderResult.dependency = array
           }
      }
      @discardableResult
      public func setDependency(_ value:Array<String>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.dependency = value
        return self
      }
      @discardableResult
      public func clearDependency() -> Google.Protobuf.FileDescriptorProto.Builder {
         builderResult.dependency.removeAll(keepingCapacity: false)
         return self
      }
      public var publicDependency:Array<Int32> {
           get {
               return builderResult.publicDependency
           }
           set (array) {
               builderResult.publicDependency = array
           }
      }
      @discardableResult
      public func setPublicDependency(_ value:Array<Int32>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.publicDependency = value
        return self
      }
      @discardableResult
      public func clearPublicDependency() -> Google.Protobuf.FileDescriptorProto.Builder {
         builderResult.publicDependency.removeAll(keepingCapacity: false)
         return self
      }
      public var weakDependency:Array<Int32> {
           get {
               return builderResult.weakDependency
           }
           set (array) {
               builderResult.weakDependency = array
           }
      }
      @discardableResult
      public func setWeakDependency(_ value:Array<Int32>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.weakDependency = value
        return self
      }
      @discardableResult
      public func clearWeakDependency() -> Google.Protobuf.FileDescriptorProto.Builder {
         builderResult.weakDependency.removeAll(keepingCapacity: false)
         return self
      }
      public var messageType:Array<Google.Protobuf.DescriptorProto> {
           get {
               return builderResult.messageType
           }
           set (value) {
               builderResult.messageType = value
           }
      }
      @discardableResult
      public func setMessageType(_ value:Array<Google.Protobuf.DescriptorProto>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.messageType = value
        return self
      }
      @discardableResult
      public func clearMessageType() -> Google.Protobuf.FileDescriptorProto.Builder {
        builderResult.messageType.removeAll(keepingCapacity: false)
        return self
      }
      public var enumType:Array<Google.Protobuf.EnumDescriptorProto> {
           get {
               return builderResult.enumType
           }
           set (value) {
               builderResult.enumType = value
           }
      }
      @discardableResult
      public func setEnumType(_ value:Array<Google.Protobuf.EnumDescriptorProto>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.enumType = value
        return self
      }
      @discardableResult
      public func clearEnumType() -> Google.Protobuf.FileDescriptorProto.Builder {
        builderResult.enumType.removeAll(keepingCapacity: false)
        return self
      }
      public var service:Array<Google.Protobuf.ServiceDescriptorProto> {
           get {
               return builderResult.service
           }
           set (value) {
               builderResult.service = value
           }
      }
      @discardableResult
      public func setService(_ value:Array<Google.Protobuf.ServiceDescriptorProto>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.service = value
        return self
      }
      @discardableResult
      public func clearService() -> Google.Protobuf.FileDescriptorProto.Builder {
        builderResult.service.removeAll(keepingCapacity: false)
        return self
      }
      public var `extension`:Array<Google.Protobuf.FieldDescriptorProto> {
           get {
               return builderResult.`extension`
           }
           set (value) {
               builderResult.`extension` = value
           }
      }
      @discardableResult
      public func setExtension(_ value:Array<Google.Protobuf.FieldDescriptorProto>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.`extension` = value
        return self
      }
      @discardableResult
      public func clearExtension() -> Google.Protobuf.FileDescriptorProto.Builder {
        builderResult.`extension`.removeAll(keepingCapacity: false)
        return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.FileOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      fileprivate var optionsBuilder_:Google.Protobuf.FileOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.FileOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.FileOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(other: options)
           }
        }
        return optionsBuilder_
      }
      @discardableResult
      public func setOptions(_ value:Google.Protobuf.FileOptions!) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.options = value
        return self
      }
      @discardableResult
      public func mergeOptions(value:Google.Protobuf.FileOptions) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.FileOptions.builderWithPrototype(prototype:builderResult.options).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      @discardableResult
      public func clearOptions() -> Google.Protobuf.FileDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      public var hasSourceCodeInfo:Bool {
           get {
               return builderResult.hasSourceCodeInfo
           }
      }
      public var sourceCodeInfo:Google.Protobuf.SourceCodeInfo! {
           get {
               if sourceCodeInfoBuilder_ != nil {
                  builderResult.sourceCodeInfo = sourceCodeInfoBuilder_.getMessage()
               }
               return builderResult.sourceCodeInfo
           }
           set (value) {
               builderResult.hasSourceCodeInfo = true
               builderResult.sourceCodeInfo = value
           }
      }
      fileprivate var sourceCodeInfoBuilder_:Google.Protobuf.SourceCodeInfo.Builder! {
           didSet {
              builderResult.hasSourceCodeInfo = true
           }
      }
      public func getSourceCodeInfoBuilder() -> Google.Protobuf.SourceCodeInfo.Builder {
        if sourceCodeInfoBuilder_ == nil {
           sourceCodeInfoBuilder_ = Google.Protobuf.SourceCodeInfo.Builder()
           builderResult.sourceCodeInfo = sourceCodeInfoBuilder_.getMessage()
           if sourceCodeInfo != nil {
              try! sourceCodeInfoBuilder_.mergeFrom(other: sourceCodeInfo)
           }
        }
        return sourceCodeInfoBuilder_
      }
      @discardableResult
      public func setSourceCodeInfo(_ value:Google.Protobuf.SourceCodeInfo!) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.sourceCodeInfo = value
        return self
      }
      @discardableResult
      public func mergeSourceCodeInfo(value:Google.Protobuf.SourceCodeInfo) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        if builderResult.hasSourceCodeInfo {
          builderResult.sourceCodeInfo = try Google.Protobuf.SourceCodeInfo.builderWithPrototype(prototype:builderResult.sourceCodeInfo).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.sourceCodeInfo = value
        }
        builderResult.hasSourceCodeInfo = true
        return self
      }
      @discardableResult
      public func clearSourceCodeInfo() -> Google.Protobuf.FileDescriptorProto.Builder {
        sourceCodeInfoBuilder_ = nil
        builderResult.hasSourceCodeInfo = false
        builderResult.sourceCodeInfo = nil
        return self
      }
      public var hasSyntax:Bool {
           get {
                return builderResult.hasSyntax
           }
      }
      public var syntax:String {
           get {
                return builderResult.syntax
           }
           set (value) {
               builderResult.hasSyntax = true
               builderResult.syntax = value
           }
      }
      @discardableResult
      public func setSyntax(_ value:String) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.syntax = value
        return self
      }
      @discardableResult
      public func clearSyntax() -> Google.Protobuf.FileDescriptorProto.Builder{
           builderResult.hasSyntax = false
           builderResult.syntax = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.FileDescriptorProto.Builder {
        builderResult = Google.Protobuf.FileDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.FileDescriptorProto.Builder {
        return try Google.Protobuf.FileDescriptorProto.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.FileDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.FileDescriptorProto {
        let returnMe:Google.Protobuf.FileDescriptorProto = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.FileDescriptorProto) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        if other == Google.Protobuf.FileDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if other.hasPackage {
             package = other.package
        }
        if !other.dependency.isEmpty {
            builderResult.dependency += other.dependency
        }
        if !other.publicDependency.isEmpty {
            builderResult.publicDependency += other.publicDependency
        }
        if !other.weakDependency.isEmpty {
            builderResult.weakDependency += other.weakDependency
        }
        if !other.messageType.isEmpty  {
           builderResult.messageType += other.messageType
        }
        if !other.enumType.isEmpty  {
           builderResult.enumType += other.enumType
        }
        if !other.service.isEmpty  {
           builderResult.service += other.service
        }
        if !other.`extension`.isEmpty  {
           builderResult.`extension` += other.`extension`
        }
        if (other.hasOptions) {
            try mergeOptions(value: other.options)
        }
        if (other.hasSourceCodeInfo) {
            try mergeSourceCodeInfo(value: other.sourceCodeInfo)
        }
        if other.hasSyntax {
             syntax = other.syntax
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.FileDescriptorProto.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try codedInputStream.readString()

          case 18:
            package = try codedInputStream.readString()

          case 26:
            dependency += [try codedInputStream.readString()]

          case 34:
            let subBuilder = Google.Protobuf.DescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            messageType.append(subBuilder.buildPartial())

          case 42:
            let subBuilder = Google.Protobuf.EnumDescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            enumType.append(subBuilder.buildPartial())

          case 50:
            let subBuilder = Google.Protobuf.ServiceDescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            service.append(subBuilder.buildPartial())

          case 58:
            let subBuilder = Google.Protobuf.FieldDescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            `extension`.append(subBuilder.buildPartial())

          case 66:
            let subBuilder:Google.Protobuf.FileOptions.Builder = Google.Protobuf.FileOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(other: options)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          case 74:
            let subBuilder:Google.Protobuf.SourceCodeInfo.Builder = Google.Protobuf.SourceCodeInfo.Builder()
            if hasSourceCodeInfo {
              try subBuilder.mergeFrom(other: sourceCodeInfo)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            sourceCodeInfo = subBuilder.buildPartial()

          case 80:
            publicDependency += [try codedInputStream.readInt32()]

          case 88:
            weakDependency += [try codedInputStream.readInt32()]

          case 98:
            syntax = try codedInputStream.readString()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.FileDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValuePackage = jsonMap["package"] as? String {
          resultDecodedBuilder.package = jsonValuePackage
        }
        if let jsonValueDependency = jsonMap["dependency"] as? Array<String> {
          var jsonArrayDependency:Array<String> = []
          for oneValueDependency in jsonValueDependency {
            jsonArrayDependency.append(oneValueDependency)
          }
          resultDecodedBuilder.dependency = jsonArrayDependency
        }
        if let jsonValuePublicDependency = jsonMap["publicDependency"] as? Array<Int> {
          var jsonArrayPublicDependency:Array<Int32> = []
          for oneValuePublicDependency in jsonValuePublicDependency {
            jsonArrayPublicDependency.append(Int32(oneValuePublicDependency))
          }
          resultDecodedBuilder.publicDependency = jsonArrayPublicDependency
        }
        if let jsonValueWeakDependency = jsonMap["weakDependency"] as? Array<Int> {
          var jsonArrayWeakDependency:Array<Int32> = []
          for oneValueWeakDependency in jsonValueWeakDependency {
            jsonArrayWeakDependency.append(Int32(oneValueWeakDependency))
          }
          resultDecodedBuilder.weakDependency = jsonArrayWeakDependency
        }
        if let jsonValueMessageType = jsonMap["messageType"] as? Array<Dictionary<String,Any>> {
          var jsonArrayMessageType:Array<Google.Protobuf.DescriptorProto> = []
          for oneValueMessageType in jsonValueMessageType {
            let messageFromStringMessageType = try Google.Protobuf.DescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueMessageType).build()

            jsonArrayMessageType.append(messageFromStringMessageType)
          }
          resultDecodedBuilder.messageType = jsonArrayMessageType
        }
        if let jsonValueEnumType = jsonMap["enumType"] as? Array<Dictionary<String,Any>> {
          var jsonArrayEnumType:Array<Google.Protobuf.EnumDescriptorProto> = []
          for oneValueEnumType in jsonValueEnumType {
            let messageFromStringEnumType = try Google.Protobuf.EnumDescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueEnumType).build()

            jsonArrayEnumType.append(messageFromStringEnumType)
          }
          resultDecodedBuilder.enumType = jsonArrayEnumType
        }
        if let jsonValueService = jsonMap["service"] as? Array<Dictionary<String,Any>> {
          var jsonArrayService:Array<Google.Protobuf.ServiceDescriptorProto> = []
          for oneValueService in jsonValueService {
            let messageFromStringService = try Google.Protobuf.ServiceDescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueService).build()

            jsonArrayService.append(messageFromStringService)
          }
          resultDecodedBuilder.service = jsonArrayService
        }
        if let jsonValueExtension = jsonMap["extension"] as? Array<Dictionary<String,Any>> {
          var jsonArrayExtension:Array<Google.Protobuf.FieldDescriptorProto> = []
          for oneValueExtension in jsonValueExtension {
            let messageFromStringExtension = try Google.Protobuf.FieldDescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueExtension).build()

            jsonArrayExtension.append(messageFromStringExtension)
          }
          resultDecodedBuilder.`extension` = jsonArrayExtension
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,Any> {
          resultDecodedBuilder.options = try Google.Protobuf.FileOptions.Builder.decodeToBuilder(jsonMap:jsonValueOptions).build()

        }
        if let jsonValueSourceCodeInfo = jsonMap["sourceCodeInfo"] as? Dictionary<String,Any> {
          resultDecodedBuilder.sourceCodeInfo = try Google.Protobuf.SourceCodeInfo.Builder.decodeToBuilder(jsonMap:jsonValueSourceCodeInfo).build()

        }
        if let jsonValueSyntax = jsonMap["syntax"] as? String {
          resultDecodedBuilder.syntax = jsonValueSyntax
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.FileDescriptorProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // Describes a message type.
  final public class DescriptorProto : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.DescriptorProto, rhs: Google.Protobuf.DescriptorProto) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
      fieldCheck = fieldCheck && (lhs.field == rhs.field)
      fieldCheck = fieldCheck && (lhs.nestedType == rhs.nestedType)
      fieldCheck = fieldCheck && (lhs.enumType == rhs.enumType)
      fieldCheck = fieldCheck && (lhs.extensionRange == rhs.extensionRange)
      fieldCheck = fieldCheck && (lhs.`extension` == rhs.`extension`)
      fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
      fieldCheck = fieldCheck && (lhs.oneofDecl == rhs.oneofDecl)
      fieldCheck = fieldCheck && (lhs.reservedRange == rhs.reservedRange)
      fieldCheck = fieldCheck && (lhs.reservedName == rhs.reservedName)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



    //Nested type declaration start

      final public class ExtensionRange : GeneratedMessage {

        public static func == (lhs: Google.Protobuf.DescriptorProto.ExtensionRange, rhs: Google.Protobuf.DescriptorProto.ExtensionRange) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasStart == rhs.hasStart) && (!lhs.hasStart || lhs.start == rhs.start)
          fieldCheck = fieldCheck && (lhs.hasEnd == rhs.hasEnd) && (!lhs.hasEnd || lhs.end == rhs.end)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        public fileprivate(set) var start:Int32 = Int32(0)
        public fileprivate(set) var hasStart:Bool = false

        public fileprivate(set) var end:Int32 = Int32(0)
        public fileprivate(set) var hasEnd:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasStart {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:start)
          }
          if hasEnd {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:end)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasStart {
            serialize_size += start.computeInt32Size(fieldNumber: 1)
          }
          if hasEnd {
            serialize_size += end.computeInt32Size(fieldNumber: 2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
          return Google.Protobuf.DescriptorProto.ExtensionRange.classBuilder() as! Google.Protobuf.DescriptorProto.ExtensionRange.Builder
        }
        public func getBuilder() -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
          return classBuilder() as! Google.Protobuf.DescriptorProto.ExtensionRange.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Google.Protobuf.DescriptorProto.ExtensionRange.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Google.Protobuf.DescriptorProto.ExtensionRange.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.DescriptorProto.ExtensionRange) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasStart {
            jsonMap["start"] = Int(start)
          }
          if hasEnd {
            jsonMap["end"] = Int(end)
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasStart {
            output += "\(indent) start: \(start) \n"
          }
          if hasEnd {
            output += "\(indent) end: \(end) \n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStart {
                   hashCode = (hashCode &* 31) &+ start.hashValue
                }
                if hasEnd {
                   hashCode = (hashCode &* 31) &+ end.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.DescriptorProto.ExtensionRange"
        }
        override public func className() -> String {
            return "Google.Protobuf.DescriptorProto.ExtensionRange"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:Google.Protobuf.DescriptorProto.ExtensionRange = Google.Protobuf.DescriptorProto.ExtensionRange()
          public func getMessage() -> Google.Protobuf.DescriptorProto.ExtensionRange {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasStart:Bool {
               get {
                    return builderResult.hasStart
               }
          }
          public var start:Int32 {
               get {
                    return builderResult.start
               }
               set (value) {
                   builderResult.hasStart = true
                   builderResult.start = value
               }
          }
          @discardableResult
          public func setStart(_ value:Int32) -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            self.start = value
            return self
          }
          @discardableResult
          public func clearStart() -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder{
               builderResult.hasStart = false
               builderResult.start = Int32(0)
               return self
          }
          public var hasEnd:Bool {
               get {
                    return builderResult.hasEnd
               }
          }
          public var end:Int32 {
               get {
                    return builderResult.end
               }
               set (value) {
                   builderResult.hasEnd = true
                   builderResult.end = value
               }
          }
          @discardableResult
          public func setEnd(_ value:Int32) -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            self.end = value
            return self
          }
          @discardableResult
          public func clearEnd() -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder{
               builderResult.hasEnd = false
               builderResult.end = Int32(0)
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            builderResult = Google.Protobuf.DescriptorProto.ExtensionRange()
            return self
          }
          override public func clone() throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            return try Google.Protobuf.DescriptorProto.ExtensionRange.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Google.Protobuf.DescriptorProto.ExtensionRange {
            let returnMe:Google.Protobuf.DescriptorProto.ExtensionRange = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:Google.Protobuf.DescriptorProto.ExtensionRange) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            if other == Google.Protobuf.DescriptorProto.ExtensionRange() {
             return self
            }
            if other.hasStart {
                 start = other.start
            }
            if other.hasEnd {
                 end = other.end
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8:
                start = try codedInputStream.readInt32()

              case 16:
                end = try codedInputStream.readInt32()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            let resultDecodedBuilder = Google.Protobuf.DescriptorProto.ExtensionRange.Builder()
            if let jsonValueStart = jsonMap["start"] as? Int {
              resultDecodedBuilder.start = Int32(jsonValueStart)
            }
            if let jsonValueEnd = jsonMap["end"] as? Int {
              resultDecodedBuilder.end = Int32(jsonValueEnd)
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      // Range of reserved tag numbers. Reserved tag numbers may not be used by
      // fields or extension ranges in the same message. Reserved ranges may
      // not overlap.
      final public class ReservedRange : GeneratedMessage {

        public static func == (lhs: Google.Protobuf.DescriptorProto.ReservedRange, rhs: Google.Protobuf.DescriptorProto.ReservedRange) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasStart == rhs.hasStart) && (!lhs.hasStart || lhs.start == rhs.start)
          fieldCheck = fieldCheck && (lhs.hasEnd == rhs.hasEnd) && (!lhs.hasEnd || lhs.end == rhs.end)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        // Inclusive.
        public fileprivate(set) var start:Int32 = Int32(0)
        public fileprivate(set) var hasStart:Bool = false

        // Exclusive.
        public fileprivate(set) var end:Int32 = Int32(0)
        public fileprivate(set) var hasEnd:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasStart {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:start)
          }
          if hasEnd {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:end)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasStart {
            serialize_size += start.computeInt32Size(fieldNumber: 1)
          }
          if hasEnd {
            serialize_size += end.computeInt32Size(fieldNumber: 2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
          return Google.Protobuf.DescriptorProto.ReservedRange.classBuilder() as! Google.Protobuf.DescriptorProto.ReservedRange.Builder
        }
        public func getBuilder() -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
          return classBuilder() as! Google.Protobuf.DescriptorProto.ReservedRange.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Google.Protobuf.DescriptorProto.ReservedRange.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Google.Protobuf.DescriptorProto.ReservedRange.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
          return try Google.Protobuf.DescriptorProto.ReservedRange.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.DescriptorProto.ReservedRange) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasStart {
            jsonMap["start"] = Int(start)
          }
          if hasEnd {
            jsonMap["end"] = Int(end)
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasStart {
            output += "\(indent) start: \(start) \n"
          }
          if hasEnd {
            output += "\(indent) end: \(end) \n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStart {
                   hashCode = (hashCode &* 31) &+ start.hashValue
                }
                if hasEnd {
                   hashCode = (hashCode &* 31) &+ end.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.DescriptorProto.ReservedRange"
        }
        override public func className() -> String {
            return "Google.Protobuf.DescriptorProto.ReservedRange"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:Google.Protobuf.DescriptorProto.ReservedRange = Google.Protobuf.DescriptorProto.ReservedRange()
          public func getMessage() -> Google.Protobuf.DescriptorProto.ReservedRange {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasStart:Bool {
               get {
                    return builderResult.hasStart
               }
          }
          public var start:Int32 {
               get {
                    return builderResult.start
               }
               set (value) {
                   builderResult.hasStart = true
                   builderResult.start = value
               }
          }
          @discardableResult
          public func setStart(_ value:Int32) -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            self.start = value
            return self
          }
          @discardableResult
          public func clearStart() -> Google.Protobuf.DescriptorProto.ReservedRange.Builder{
               builderResult.hasStart = false
               builderResult.start = Int32(0)
               return self
          }
          public var hasEnd:Bool {
               get {
                    return builderResult.hasEnd
               }
          }
          public var end:Int32 {
               get {
                    return builderResult.end
               }
               set (value) {
                   builderResult.hasEnd = true
                   builderResult.end = value
               }
          }
          @discardableResult
          public func setEnd(_ value:Int32) -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            self.end = value
            return self
          }
          @discardableResult
          public func clearEnd() -> Google.Protobuf.DescriptorProto.ReservedRange.Builder{
               builderResult.hasEnd = false
               builderResult.end = Int32(0)
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            builderResult = Google.Protobuf.DescriptorProto.ReservedRange()
            return self
          }
          override public func clone() throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            return try Google.Protobuf.DescriptorProto.ReservedRange.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> Google.Protobuf.DescriptorProto.ReservedRange {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Google.Protobuf.DescriptorProto.ReservedRange {
            let returnMe:Google.Protobuf.DescriptorProto.ReservedRange = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:Google.Protobuf.DescriptorProto.ReservedRange) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            if other == Google.Protobuf.DescriptorProto.ReservedRange() {
             return self
            }
            if other.hasStart {
                 start = other.start
            }
            if other.hasEnd {
                 end = other.end
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8:
                start = try codedInputStream.readInt32()

              case 16:
                end = try codedInputStream.readInt32()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            let resultDecodedBuilder = Google.Protobuf.DescriptorProto.ReservedRange.Builder()
            if let jsonValueStart = jsonMap["start"] as? Int {
              resultDecodedBuilder.start = Int32(jsonValueStart)
            }
            if let jsonValueEnd = jsonMap["end"] as? Int {
              resultDecodedBuilder.end = Int32(jsonValueEnd)
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Google.Protobuf.DescriptorProto.ReservedRange.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end

    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var field:Array<Google.Protobuf.FieldDescriptorProto>  = Array<Google.Protobuf.FieldDescriptorProto>()
    public fileprivate(set) var `extension`:Array<Google.Protobuf.FieldDescriptorProto>  = Array<Google.Protobuf.FieldDescriptorProto>()
    public fileprivate(set) var nestedType:Array<Google.Protobuf.DescriptorProto>  = Array<Google.Protobuf.DescriptorProto>()
    public fileprivate(set) var enumType:Array<Google.Protobuf.EnumDescriptorProto>  = Array<Google.Protobuf.EnumDescriptorProto>()
    public fileprivate(set) var extensionRange:Array<Google.Protobuf.DescriptorProto.ExtensionRange>  = Array<Google.Protobuf.DescriptorProto.ExtensionRange>()
    public fileprivate(set) var oneofDecl:Array<Google.Protobuf.OneofDescriptorProto>  = Array<Google.Protobuf.OneofDescriptorProto>()
    public fileprivate(set) var options:Google.Protobuf.MessageOptions!
    public fileprivate(set) var hasOptions:Bool = false
    public fileprivate(set) var reservedRange:Array<Google.Protobuf.DescriptorProto.ReservedRange>  = Array<Google.Protobuf.DescriptorProto.ReservedRange>()
    // Reserved field names, which may not be used by fields in the same message.
    // A given name may only be reserved once.
    public fileprivate(set) var reservedName:Array<String> = Array<String>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitField:Bool = true
      for oneElementField in field {
        if !oneElementField.isInitialized() {
          isInitField = false
          break 
        }
      }
      if !isInitField {
        return isInitField
      }
      var isInitExtension:Bool = true
      for oneElementExtension in `extension` {
        if !oneElementExtension.isInitialized() {
          isInitExtension = false
          break 
        }
      }
      if !isInitExtension {
        return isInitExtension
      }
      var isInitNestedType:Bool = true
      for oneElementNestedType in nestedType {
        if !oneElementNestedType.isInitialized() {
          isInitNestedType = false
          break 
        }
      }
      if !isInitNestedType {
        return isInitNestedType
      }
      var isInitEnumType:Bool = true
      for oneElementEnumType in enumType {
        if !oneElementEnumType.isInitialized() {
          isInitEnumType = false
          break 
        }
      }
      if !isInitEnumType {
        return isInitEnumType
      }
      var isInitOneofDecl:Bool = true
      for oneElementOneofDecl in oneofDecl {
        if !oneElementOneofDecl.isInitialized() {
          isInitOneofDecl = false
          break 
        }
      }
      if !isInitOneofDecl {
        return isInitOneofDecl
      }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasName {
        try codedOutputStream.writeString(fieldNumber: 1, value:name)
      }
      for oneElementField in field {
          try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementField)
      }
      for oneElementNestedType in nestedType {
          try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementNestedType)
      }
      for oneElementEnumType in enumType {
          try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementEnumType)
      }
      for oneElementExtensionRange in extensionRange {
          try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementExtensionRange)
      }
      for oneElementExtension in `extension` {
          try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementExtension)
      }
      if hasOptions {
        try codedOutputStream.writeMessage(fieldNumber: 7, value:options)
      }
      for oneElementOneofDecl in oneofDecl {
          try codedOutputStream.writeMessage(fieldNumber: 8, value:oneElementOneofDecl)
      }
      for oneElementReservedRange in reservedRange {
          try codedOutputStream.writeMessage(fieldNumber: 9, value:oneElementReservedRange)
      }
      if !reservedName.isEmpty {
        for oneValuereservedName in reservedName {
          try codedOutputStream.writeString(fieldNumber: 10, value:oneValuereservedName)
        }
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(fieldNumber: 1)
      }
      for oneElementField in field {
          serialize_size += oneElementField.computeMessageSize(fieldNumber: 2)
      }
      for oneElementNestedType in nestedType {
          serialize_size += oneElementNestedType.computeMessageSize(fieldNumber: 3)
      }
      for oneElementEnumType in enumType {
          serialize_size += oneElementEnumType.computeMessageSize(fieldNumber: 4)
      }
      for oneElementExtensionRange in extensionRange {
          serialize_size += oneElementExtensionRange.computeMessageSize(fieldNumber: 5)
      }
      for oneElementExtension in `extension` {
          serialize_size += oneElementExtension.computeMessageSize(fieldNumber: 6)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(fieldNumber: 7) {
              serialize_size += varSizeoptions
          }
      }
      for oneElementOneofDecl in oneofDecl {
          serialize_size += oneElementOneofDecl.computeMessageSize(fieldNumber: 8)
      }
      for oneElementReservedRange in reservedRange {
          serialize_size += oneElementReservedRange.computeMessageSize(fieldNumber: 9)
      }
      var dataSizeReservedName:Int32 = 0
      for oneValuereservedName in reservedName {
          dataSizeReservedName += oneValuereservedName.computeStringSizeNoTag()
      }
      serialize_size += dataSizeReservedName
      serialize_size += 1 * Int32(reservedName.count)
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.DescriptorProto.Builder {
      return Google.Protobuf.DescriptorProto.classBuilder() as! Google.Protobuf.DescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.DescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.DescriptorProto.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.DescriptorProto.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.DescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.DescriptorProto.Builder {
      return try Google.Protobuf.DescriptorProto.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.DescriptorProto) throws -> Google.Protobuf.DescriptorProto.Builder {
      return try Google.Protobuf.DescriptorProto.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasName {
        jsonMap["name"] = name
      }
      if !field.isEmpty {
        var jsonArrayField:Array<Dictionary<String,Any>> = []
          for oneValueField in field {
            let ecodedMessageField = try oneValueField.encode()
            jsonArrayField.append(ecodedMessageField)
          }
        jsonMap["field"] = jsonArrayField
      }
      if !`extension`.isEmpty {
        var jsonArrayExtension:Array<Dictionary<String,Any>> = []
          for oneValueExtension in `extension` {
            let ecodedMessageExtension = try oneValueExtension.encode()
            jsonArrayExtension.append(ecodedMessageExtension)
          }
        jsonMap["extension"] = jsonArrayExtension
      }
      if !nestedType.isEmpty {
        var jsonArrayNestedType:Array<Dictionary<String,Any>> = []
          for oneValueNestedType in nestedType {
            let ecodedMessageNestedType = try oneValueNestedType.encode()
            jsonArrayNestedType.append(ecodedMessageNestedType)
          }
        jsonMap["nestedType"] = jsonArrayNestedType
      }
      if !enumType.isEmpty {
        var jsonArrayEnumType:Array<Dictionary<String,Any>> = []
          for oneValueEnumType in enumType {
            let ecodedMessageEnumType = try oneValueEnumType.encode()
            jsonArrayEnumType.append(ecodedMessageEnumType)
          }
        jsonMap["enumType"] = jsonArrayEnumType
      }
      if !extensionRange.isEmpty {
        var jsonArrayExtensionRange:Array<Dictionary<String,Any>> = []
          for oneValueExtensionRange in extensionRange {
            let ecodedMessageExtensionRange = try oneValueExtensionRange.encode()
            jsonArrayExtensionRange.append(ecodedMessageExtensionRange)
          }
        jsonMap["extensionRange"] = jsonArrayExtensionRange
      }
      if !oneofDecl.isEmpty {
        var jsonArrayOneofDecl:Array<Dictionary<String,Any>> = []
          for oneValueOneofDecl in oneofDecl {
            let ecodedMessageOneofDecl = try oneValueOneofDecl.encode()
            jsonArrayOneofDecl.append(ecodedMessageOneofDecl)
          }
        jsonMap["oneofDecl"] = jsonArrayOneofDecl
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      if !reservedRange.isEmpty {
        var jsonArrayReservedRange:Array<Dictionary<String,Any>> = []
          for oneValueReservedRange in reservedRange {
            let ecodedMessageReservedRange = try oneValueReservedRange.encode()
            jsonArrayReservedRange.append(ecodedMessageReservedRange)
          }
        jsonMap["reservedRange"] = jsonArrayReservedRange
      }
      if !reservedName.isEmpty {
        var jsonArrayReservedName:Array<String> = []
          for oneValueReservedName in reservedName {
            jsonArrayReservedName.append(oneValueReservedName)
          }
        jsonMap["reservedName"] = jsonArrayReservedName
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.DescriptorProto {
      return try Google.Protobuf.DescriptorProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.DescriptorProto {
      return try Google.Protobuf.DescriptorProto.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var fieldElementIndex:Int = 0
      for oneElementField in field {
          output += "\(indent) field[\(fieldElementIndex)] {\n"
          output += try oneElementField.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          fieldElementIndex += 1
      }
      var nestedTypeElementIndex:Int = 0
      for oneElementNestedType in nestedType {
          output += "\(indent) nestedType[\(nestedTypeElementIndex)] {\n"
          output += try oneElementNestedType.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          nestedTypeElementIndex += 1
      }
      var enumTypeElementIndex:Int = 0
      for oneElementEnumType in enumType {
          output += "\(indent) enumType[\(enumTypeElementIndex)] {\n"
          output += try oneElementEnumType.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          enumTypeElementIndex += 1
      }
      var extensionRangeElementIndex:Int = 0
      for oneElementExtensionRange in extensionRange {
          output += "\(indent) extensionRange[\(extensionRangeElementIndex)] {\n"
          output += try oneElementExtensionRange.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          extensionRangeElementIndex += 1
      }
      var extensionElementIndex:Int = 0
      for oneElementExtension in `extension` {
          output += "\(indent) extension[\(extensionElementIndex)] {\n"
          output += try oneElementExtension.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          extensionElementIndex += 1
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      var oneofDeclElementIndex:Int = 0
      for oneElementOneofDecl in oneofDecl {
          output += "\(indent) oneofDecl[\(oneofDeclElementIndex)] {\n"
          output += try oneElementOneofDecl.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          oneofDeclElementIndex += 1
      }
      var reservedRangeElementIndex:Int = 0
      for oneElementReservedRange in reservedRange {
          output += "\(indent) reservedRange[\(reservedRangeElementIndex)] {\n"
          output += try oneElementReservedRange.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          reservedRangeElementIndex += 1
      }
      var reservedNameElementIndex:Int = 0
      for oneValueReservedName in reservedName  {
          output += "\(indent) reservedName[\(reservedNameElementIndex)]: \(oneValueReservedName)\n"
          reservedNameElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneElementField in field {
                hashCode = (hashCode &* 31) &+ oneElementField.hashValue
            }
            for oneElementNestedType in nestedType {
                hashCode = (hashCode &* 31) &+ oneElementNestedType.hashValue
            }
            for oneElementEnumType in enumType {
                hashCode = (hashCode &* 31) &+ oneElementEnumType.hashValue
            }
            for oneElementExtensionRange in extensionRange {
                hashCode = (hashCode &* 31) &+ oneElementExtensionRange.hashValue
            }
            for oneElementExtension in `extension` {
                hashCode = (hashCode &* 31) &+ oneElementExtension.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            for oneElementOneofDecl in oneofDecl {
                hashCode = (hashCode &* 31) &+ oneElementOneofDecl.hashValue
            }
            for oneElementReservedRange in reservedRange {
                hashCode = (hashCode &* 31) &+ oneElementReservedRange.hashValue
            }
            for oneValueReservedName in reservedName {
                hashCode = (hashCode &* 31) &+ oneValueReservedName.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.DescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.DescriptorProto"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.DescriptorProto = Google.Protobuf.DescriptorProto()
      public func getMessage() -> Google.Protobuf.DescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      @discardableResult
      public func setName(_ value:String) -> Google.Protobuf.DescriptorProto.Builder {
        self.name = value
        return self
      }
      @discardableResult
      public func clearName() -> Google.Protobuf.DescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var field:Array<Google.Protobuf.FieldDescriptorProto> {
           get {
               return builderResult.field
           }
           set (value) {
               builderResult.field = value
           }
      }
      @discardableResult
      public func setField(_ value:Array<Google.Protobuf.FieldDescriptorProto>) -> Google.Protobuf.DescriptorProto.Builder {
        self.field = value
        return self
      }
      @discardableResult
      public func clearField() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.field.removeAll(keepingCapacity: false)
        return self
      }
      public var `extension`:Array<Google.Protobuf.FieldDescriptorProto> {
           get {
               return builderResult.`extension`
           }
           set (value) {
               builderResult.`extension` = value
           }
      }
      @discardableResult
      public func setExtension(_ value:Array<Google.Protobuf.FieldDescriptorProto>) -> Google.Protobuf.DescriptorProto.Builder {
        self.`extension` = value
        return self
      }
      @discardableResult
      public func clearExtension() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.`extension`.removeAll(keepingCapacity: false)
        return self
      }
      public var nestedType:Array<Google.Protobuf.DescriptorProto> {
           get {
               return builderResult.nestedType
           }
           set (value) {
               builderResult.nestedType = value
           }
      }
      @discardableResult
      public func setNestedType(_ value:Array<Google.Protobuf.DescriptorProto>) -> Google.Protobuf.DescriptorProto.Builder {
        self.nestedType = value
        return self
      }
      @discardableResult
      public func clearNestedType() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.nestedType.removeAll(keepingCapacity: false)
        return self
      }
      public var enumType:Array<Google.Protobuf.EnumDescriptorProto> {
           get {
               return builderResult.enumType
           }
           set (value) {
               builderResult.enumType = value
           }
      }
      @discardableResult
      public func setEnumType(_ value:Array<Google.Protobuf.EnumDescriptorProto>) -> Google.Protobuf.DescriptorProto.Builder {
        self.enumType = value
        return self
      }
      @discardableResult
      public func clearEnumType() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.enumType.removeAll(keepingCapacity: false)
        return self
      }
      public var extensionRange:Array<Google.Protobuf.DescriptorProto.ExtensionRange> {
           get {
               return builderResult.extensionRange
           }
           set (value) {
               builderResult.extensionRange = value
           }
      }
      @discardableResult
      public func setExtensionRange(_ value:Array<Google.Protobuf.DescriptorProto.ExtensionRange>) -> Google.Protobuf.DescriptorProto.Builder {
        self.extensionRange = value
        return self
      }
      @discardableResult
      public func clearExtensionRange() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.extensionRange.removeAll(keepingCapacity: false)
        return self
      }
      public var oneofDecl:Array<Google.Protobuf.OneofDescriptorProto> {
           get {
               return builderResult.oneofDecl
           }
           set (value) {
               builderResult.oneofDecl = value
           }
      }
      @discardableResult
      public func setOneofDecl(_ value:Array<Google.Protobuf.OneofDescriptorProto>) -> Google.Protobuf.DescriptorProto.Builder {
        self.oneofDecl = value
        return self
      }
      @discardableResult
      public func clearOneofDecl() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.oneofDecl.removeAll(keepingCapacity: false)
        return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.MessageOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      fileprivate var optionsBuilder_:Google.Protobuf.MessageOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.MessageOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.MessageOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(other: options)
           }
        }
        return optionsBuilder_
      }
      @discardableResult
      public func setOptions(_ value:Google.Protobuf.MessageOptions!) -> Google.Protobuf.DescriptorProto.Builder {
        self.options = value
        return self
      }
      @discardableResult
      public func mergeOptions(value:Google.Protobuf.MessageOptions) throws -> Google.Protobuf.DescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.MessageOptions.builderWithPrototype(prototype:builderResult.options).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      @discardableResult
      public func clearOptions() -> Google.Protobuf.DescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      public var reservedRange:Array<Google.Protobuf.DescriptorProto.ReservedRange> {
           get {
               return builderResult.reservedRange
           }
           set (value) {
               builderResult.reservedRange = value
           }
      }
      @discardableResult
      public func setReservedRange(_ value:Array<Google.Protobuf.DescriptorProto.ReservedRange>) -> Google.Protobuf.DescriptorProto.Builder {
        self.reservedRange = value
        return self
      }
      @discardableResult
      public func clearReservedRange() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.reservedRange.removeAll(keepingCapacity: false)
        return self
      }
      public var reservedName:Array<String> {
           get {
               return builderResult.reservedName
           }
           set (array) {
               builderResult.reservedName = array
           }
      }
      @discardableResult
      public func setReservedName(_ value:Array<String>) -> Google.Protobuf.DescriptorProto.Builder {
        self.reservedName = value
        return self
      }
      @discardableResult
      public func clearReservedName() -> Google.Protobuf.DescriptorProto.Builder {
         builderResult.reservedName.removeAll(keepingCapacity: false)
         return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult = Google.Protobuf.DescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.DescriptorProto.Builder {
        return try Google.Protobuf.DescriptorProto.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.DescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.DescriptorProto {
        let returnMe:Google.Protobuf.DescriptorProto = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.DescriptorProto) throws -> Google.Protobuf.DescriptorProto.Builder {
        if other == Google.Protobuf.DescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if !other.field.isEmpty  {
           builderResult.field += other.field
        }
        if !other.`extension`.isEmpty  {
           builderResult.`extension` += other.`extension`
        }
        if !other.nestedType.isEmpty  {
           builderResult.nestedType += other.nestedType
        }
        if !other.enumType.isEmpty  {
           builderResult.enumType += other.enumType
        }
        if !other.extensionRange.isEmpty  {
           builderResult.extensionRange += other.extensionRange
        }
        if !other.oneofDecl.isEmpty  {
           builderResult.oneofDecl += other.oneofDecl
        }
        if (other.hasOptions) {
            try mergeOptions(value: other.options)
        }
        if !other.reservedRange.isEmpty  {
           builderResult.reservedRange += other.reservedRange
        }
        if !other.reservedName.isEmpty {
            builderResult.reservedName += other.reservedName
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.DescriptorProto.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try codedInputStream.readString()

          case 18:
            let subBuilder = Google.Protobuf.FieldDescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            field.append(subBuilder.buildPartial())

          case 26:
            let subBuilder = Google.Protobuf.DescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            nestedType.append(subBuilder.buildPartial())

          case 34:
            let subBuilder = Google.Protobuf.EnumDescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            enumType.append(subBuilder.buildPartial())

          case 42:
            let subBuilder = Google.Protobuf.DescriptorProto.ExtensionRange.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            extensionRange.append(subBuilder.buildPartial())

          case 50:
            let subBuilder = Google.Protobuf.FieldDescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            `extension`.append(subBuilder.buildPartial())

          case 58:
            let subBuilder:Google.Protobuf.MessageOptions.Builder = Google.Protobuf.MessageOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(other: options)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          case 66:
            let subBuilder = Google.Protobuf.OneofDescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            oneofDecl.append(subBuilder.buildPartial())

          case 74:
            let subBuilder = Google.Protobuf.DescriptorProto.ReservedRange.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            reservedRange.append(subBuilder.buildPartial())

          case 82:
            reservedName += [try codedInputStream.readString()]

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.DescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.DescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueField = jsonMap["field"] as? Array<Dictionary<String,Any>> {
          var jsonArrayField:Array<Google.Protobuf.FieldDescriptorProto> = []
          for oneValueField in jsonValueField {
            let messageFromStringField = try Google.Protobuf.FieldDescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueField).build()

            jsonArrayField.append(messageFromStringField)
          }
          resultDecodedBuilder.field = jsonArrayField
        }
        if let jsonValueExtension = jsonMap["extension"] as? Array<Dictionary<String,Any>> {
          var jsonArrayExtension:Array<Google.Protobuf.FieldDescriptorProto> = []
          for oneValueExtension in jsonValueExtension {
            let messageFromStringExtension = try Google.Protobuf.FieldDescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueExtension).build()

            jsonArrayExtension.append(messageFromStringExtension)
          }
          resultDecodedBuilder.`extension` = jsonArrayExtension
        }
        if let jsonValueNestedType = jsonMap["nestedType"] as? Array<Dictionary<String,Any>> {
          var jsonArrayNestedType:Array<Google.Protobuf.DescriptorProto> = []
          for oneValueNestedType in jsonValueNestedType {
            let messageFromStringNestedType = try Google.Protobuf.DescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueNestedType).build()

            jsonArrayNestedType.append(messageFromStringNestedType)
          }
          resultDecodedBuilder.nestedType = jsonArrayNestedType
        }
        if let jsonValueEnumType = jsonMap["enumType"] as? Array<Dictionary<String,Any>> {
          var jsonArrayEnumType:Array<Google.Protobuf.EnumDescriptorProto> = []
          for oneValueEnumType in jsonValueEnumType {
            let messageFromStringEnumType = try Google.Protobuf.EnumDescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueEnumType).build()

            jsonArrayEnumType.append(messageFromStringEnumType)
          }
          resultDecodedBuilder.enumType = jsonArrayEnumType
        }
        if let jsonValueExtensionRange = jsonMap["extensionRange"] as? Array<Dictionary<String,Any>> {
          var jsonArrayExtensionRange:Array<Google.Protobuf.DescriptorProto.ExtensionRange> = []
          for oneValueExtensionRange in jsonValueExtensionRange {
            let messageFromStringExtensionRange = try Google.Protobuf.DescriptorProto.ExtensionRange.Builder.decodeToBuilder(jsonMap:oneValueExtensionRange).build()

            jsonArrayExtensionRange.append(messageFromStringExtensionRange)
          }
          resultDecodedBuilder.extensionRange = jsonArrayExtensionRange
        }
        if let jsonValueOneofDecl = jsonMap["oneofDecl"] as? Array<Dictionary<String,Any>> {
          var jsonArrayOneofDecl:Array<Google.Protobuf.OneofDescriptorProto> = []
          for oneValueOneofDecl in jsonValueOneofDecl {
            let messageFromStringOneofDecl = try Google.Protobuf.OneofDescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueOneofDecl).build()

            jsonArrayOneofDecl.append(messageFromStringOneofDecl)
          }
          resultDecodedBuilder.oneofDecl = jsonArrayOneofDecl
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,Any> {
          resultDecodedBuilder.options = try Google.Protobuf.MessageOptions.Builder.decodeToBuilder(jsonMap:jsonValueOptions).build()

        }
        if let jsonValueReservedRange = jsonMap["reservedRange"] as? Array<Dictionary<String,Any>> {
          var jsonArrayReservedRange:Array<Google.Protobuf.DescriptorProto.ReservedRange> = []
          for oneValueReservedRange in jsonValueReservedRange {
            let messageFromStringReservedRange = try Google.Protobuf.DescriptorProto.ReservedRange.Builder.decodeToBuilder(jsonMap:oneValueReservedRange).build()

            jsonArrayReservedRange.append(messageFromStringReservedRange)
          }
          resultDecodedBuilder.reservedRange = jsonArrayReservedRange
        }
        if let jsonValueReservedName = jsonMap["reservedName"] as? Array<String> {
          var jsonArrayReservedName:Array<String> = []
          for oneValueReservedName in jsonValueReservedName {
            jsonArrayReservedName.append(oneValueReservedName)
          }
          resultDecodedBuilder.reservedName = jsonArrayReservedName
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.DescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.DescriptorProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // Describes a field within a message.
  final public class FieldDescriptorProto : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.FieldDescriptorProto, rhs: Google.Protobuf.FieldDescriptorProto) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
      fieldCheck = fieldCheck && (lhs.hasExtendee == rhs.hasExtendee) && (!lhs.hasExtendee || lhs.extendee == rhs.extendee)
      fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
      fieldCheck = fieldCheck && (lhs.hasLabel == rhs.hasLabel) && (!lhs.hasLabel || lhs.label == rhs.label)
      fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
      fieldCheck = fieldCheck && (lhs.hasTypeName == rhs.hasTypeName) && (!lhs.hasTypeName || lhs.typeName == rhs.typeName)
      fieldCheck = fieldCheck && (lhs.hasDefaultValue == rhs.hasDefaultValue) && (!lhs.hasDefaultValue || lhs.defaultValue == rhs.defaultValue)
      fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
      fieldCheck = fieldCheck && (lhs.hasOneofIndex == rhs.hasOneofIndex) && (!lhs.hasOneofIndex || lhs.oneofIndex == rhs.oneofIndex)
      fieldCheck = fieldCheck && (lhs.hasJsonName == rhs.hasJsonName) && (!lhs.hasJsonName || lhs.jsonName == rhs.jsonName)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum `Type`:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // 0 is reserved for errors.
        // Order is weird for historical reasons.
        case typeDouble = 1
        case typeFloat = 2

        // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
        // negative values are likely.
        case typeInt64 = 3
        case typeUint64 = 4

        // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
        // negative values are likely.
        case typeInt32 = 5
        case typeFixed64 = 6
        case typeFixed32 = 7
        case typeBool = 8
        case typeString = 9

        // Tag-delimited aggregate.
        case typeGroup = 10

        // Length-delimited aggregate.
        case typeMessage = 11

        // New in version 2.
        case typeBytes = 12
        case typeUint32 = 13
        case typeEnum = 14
        case typeSfixed32 = 15
        case typeSfixed64 = 16

        // Uses ZigZag encoding.
        case typeSint32 = 17

        // Uses ZigZag encoding.
        case typeSint64 = 18
        public func toString() -> String {
          switch self {
          case .typeDouble: return "TYPE_DOUBLE"
          case .typeFloat: return "TYPE_FLOAT"
          case .typeInt64: return "TYPE_INT64"
          case .typeUint64: return "TYPE_UINT64"
          case .typeInt32: return "TYPE_INT32"
          case .typeFixed64: return "TYPE_FIXED64"
          case .typeFixed32: return "TYPE_FIXED32"
          case .typeBool: return "TYPE_BOOL"
          case .typeString: return "TYPE_STRING"
          case .typeGroup: return "TYPE_GROUP"
          case .typeMessage: return "TYPE_MESSAGE"
          case .typeBytes: return "TYPE_BYTES"
          case .typeUint32: return "TYPE_UINT32"
          case .typeEnum: return "TYPE_ENUM"
          case .typeSfixed32: return "TYPE_SFIXED32"
          case .typeSfixed64: return "TYPE_SFIXED64"
          case .typeSint32: return "TYPE_SINT32"
          case .typeSint64: return "TYPE_SINT64"
          }
        }
        public static func fromString(str:String) throws -> Google.Protobuf.FieldDescriptorProto.`Type` {
          switch str {
          case "TYPE_DOUBLE":  return .typeDouble
          case "TYPE_FLOAT":  return .typeFloat
          case "TYPE_INT64":  return .typeInt64
          case "TYPE_UINT64":  return .typeUint64
          case "TYPE_INT32":  return .typeInt32
          case "TYPE_FIXED64":  return .typeFixed64
          case "TYPE_FIXED32":  return .typeFixed32
          case "TYPE_BOOL":  return .typeBool
          case "TYPE_STRING":  return .typeString
          case "TYPE_GROUP":  return .typeGroup
          case "TYPE_MESSAGE":  return .typeMessage
          case "TYPE_BYTES":  return .typeBytes
          case "TYPE_UINT32":  return .typeUint32
          case "TYPE_ENUM":  return .typeEnum
          case "TYPE_SFIXED32":  return .typeSfixed32
          case "TYPE_SFIXED64":  return .typeSfixed64
          case "TYPE_SINT32":  return .typeSint32
          case "TYPE_SINT64":  return .typeSint64
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .typeDouble: return ".typeDouble"
          case .typeFloat: return ".typeFloat"
          case .typeInt64: return ".typeInt64"
          case .typeUint64: return ".typeUint64"
          case .typeInt32: return ".typeInt32"
          case .typeFixed64: return ".typeFixed64"
          case .typeFixed32: return ".typeFixed32"
          case .typeBool: return ".typeBool"
          case .typeString: return ".typeString"
          case .typeGroup: return ".typeGroup"
          case .typeMessage: return ".typeMessage"
          case .typeBytes: return ".typeBytes"
          case .typeUint32: return ".typeUint32"
          case .typeEnum: return ".typeEnum"
          case .typeSfixed32: return ".typeSfixed32"
          case .typeSfixed64: return ".typeSfixed64"
          case .typeSint32: return ".typeSint32"
          case .typeSint64: return ".typeSint64"
          }
        }
      }

      //Enum type declaration end 



      //Enum type declaration start 

      public enum Label:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // 0 is reserved for errors
        case labelOptional = 1
        case labelRequired = 2

        // TODO(sanjay): Should we add LABEL_MAP?
        case labelRepeated = 3
        public func toString() -> String {
          switch self {
          case .labelOptional: return "LABEL_OPTIONAL"
          case .labelRequired: return "LABEL_REQUIRED"
          case .labelRepeated: return "LABEL_REPEATED"
          }
        }
        public static func fromString(str:String) throws -> Google.Protobuf.FieldDescriptorProto.Label {
          switch str {
          case "LABEL_OPTIONAL":  return .labelOptional
          case "LABEL_REQUIRED":  return .labelRequired
          case "LABEL_REPEATED":  return .labelRepeated
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .labelOptional: return ".labelOptional"
          case .labelRequired: return ".labelRequired"
          case .labelRepeated: return ".labelRepeated"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var number:Int32 = Int32(0)
    public fileprivate(set) var hasNumber:Bool = false

    public fileprivate(set) var label:Google.Protobuf.FieldDescriptorProto.Label = Google.Protobuf.FieldDescriptorProto.Label.labelOptional
    public fileprivate(set) var hasLabel:Bool = false
    public fileprivate(set) var type:Google.Protobuf.FieldDescriptorProto.`Type` = Google.Protobuf.FieldDescriptorProto.`Type`.typeDouble
    public fileprivate(set) var hasType:Bool = false
    // For message and enum types, this is the name of the type.  If the name
    // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
    // rules are used to find the type (i.e. first the nested types within this
    // message are searched, then within the parent, on up to the root
    // namespace).
    public fileprivate(set) var typeName:String = ""
    public fileprivate(set) var hasTypeName:Bool = false

    // For extensions, this is the name of the type being extended.  It is
    // resolved in the same manner as type_name.
    public fileprivate(set) var extendee:String = ""
    public fileprivate(set) var hasExtendee:Bool = false

    // For numeric types, contains the original text representation of the value.
    // For booleans, "true" or "false".
    // For strings, contains the default text contents (not escaped in any way).
    // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
    // TODO(kenton):  Base-64 encode?
    public fileprivate(set) var defaultValue:String = ""
    public fileprivate(set) var hasDefaultValue:Bool = false

    // If set, gives the index of a oneof in the containing type's oneof_decl
    // list.  This field is a member of that oneof.
    public fileprivate(set) var oneofIndex:Int32 = Int32(0)
    public fileprivate(set) var hasOneofIndex:Bool = false

    // JSON name of this field. The value is set by protocol compiler. If the
    // user has set a "json_name" option on this field, that option's value
    // will be used. Otherwise, it's deduced from the field's name by converting
    // it to camelCase.
    public fileprivate(set) var jsonName:String = ""
    public fileprivate(set) var hasJsonName:Bool = false

    public fileprivate(set) var options:Google.Protobuf.FieldOptions!
    public fileprivate(set) var hasOptions:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasName {
        try codedOutputStream.writeString(fieldNumber: 1, value:name)
      }
      if hasExtendee {
        try codedOutputStream.writeString(fieldNumber: 2, value:extendee)
      }
      if hasNumber {
        try codedOutputStream.writeInt32(fieldNumber: 3, value:number)
      }
      if hasLabel {
        try codedOutputStream.writeEnum(fieldNumber: 4, value:label.rawValue)
      }
      if hasType {
        try codedOutputStream.writeEnum(fieldNumber: 5, value:type.rawValue)
      }
      if hasTypeName {
        try codedOutputStream.writeString(fieldNumber: 6, value:typeName)
      }
      if hasDefaultValue {
        try codedOutputStream.writeString(fieldNumber: 7, value:defaultValue)
      }
      if hasOptions {
        try codedOutputStream.writeMessage(fieldNumber: 8, value:options)
      }
      if hasOneofIndex {
        try codedOutputStream.writeInt32(fieldNumber: 9, value:oneofIndex)
      }
      if hasJsonName {
        try codedOutputStream.writeString(fieldNumber: 10, value:jsonName)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(fieldNumber: 1)
      }
      if hasExtendee {
        serialize_size += extendee.computeStringSize(fieldNumber: 2)
      }
      if hasNumber {
        serialize_size += number.computeInt32Size(fieldNumber: 3)
      }
      if (hasLabel) {
        serialize_size += label.rawValue.computeEnumSize(fieldNumber: 4)
      }
      if (hasType) {
        serialize_size += type.rawValue.computeEnumSize(fieldNumber: 5)
      }
      if hasTypeName {
        serialize_size += typeName.computeStringSize(fieldNumber: 6)
      }
      if hasDefaultValue {
        serialize_size += defaultValue.computeStringSize(fieldNumber: 7)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(fieldNumber: 8) {
              serialize_size += varSizeoptions
          }
      }
      if hasOneofIndex {
        serialize_size += oneofIndex.computeInt32Size(fieldNumber: 9)
      }
      if hasJsonName {
        serialize_size += jsonName.computeStringSize(fieldNumber: 10)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.FieldDescriptorProto.Builder {
      return Google.Protobuf.FieldDescriptorProto.classBuilder() as! Google.Protobuf.FieldDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.FieldDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.FieldDescriptorProto.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.FieldDescriptorProto.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.FieldDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.FieldDescriptorProto.Builder {
      return try Google.Protobuf.FieldDescriptorProto.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.FieldDescriptorProto) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
      return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasName {
        jsonMap["name"] = name
      }
      if hasNumber {
        jsonMap["number"] = Int(number)
      }
      if hasLabel {
        jsonMap["label"] = label.toString()
      }
      if hasType {
        jsonMap["type"] = type.toString()
      }
      if hasTypeName {
        jsonMap["typeName"] = typeName
      }
      if hasExtendee {
        jsonMap["extendee"] = extendee
      }
      if hasDefaultValue {
        jsonMap["defaultValue"] = defaultValue
      }
      if hasOneofIndex {
        jsonMap["oneofIndex"] = Int(oneofIndex)
      }
      if hasJsonName {
        jsonMap["jsonName"] = jsonName
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.FieldDescriptorProto {
      return try Google.Protobuf.FieldDescriptorProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.FieldDescriptorProto {
      return try Google.Protobuf.FieldDescriptorProto.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasExtendee {
        output += "\(indent) extendee: \(extendee) \n"
      }
      if hasNumber {
        output += "\(indent) number: \(number) \n"
      }
      if (hasLabel) {
        output += "\(indent) label: \(label.description)\n"
      }
      if (hasType) {
        output += "\(indent) type: \(type.description)\n"
      }
      if hasTypeName {
        output += "\(indent) typeName: \(typeName) \n"
      }
      if hasDefaultValue {
        output += "\(indent) defaultValue: \(defaultValue) \n"
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasOneofIndex {
        output += "\(indent) oneofIndex: \(oneofIndex) \n"
      }
      if hasJsonName {
        output += "\(indent) jsonName: \(jsonName) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasExtendee {
               hashCode = (hashCode &* 31) &+ extendee.hashValue
            }
            if hasNumber {
               hashCode = (hashCode &* 31) &+ number.hashValue
            }
            if hasLabel {
               hashCode = (hashCode &* 31) &+ Int(label.rawValue)
            }
            if hasType {
               hashCode = (hashCode &* 31) &+ Int(type.rawValue)
            }
            if hasTypeName {
               hashCode = (hashCode &* 31) &+ typeName.hashValue
            }
            if hasDefaultValue {
               hashCode = (hashCode &* 31) &+ defaultValue.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            if hasOneofIndex {
               hashCode = (hashCode &* 31) &+ oneofIndex.hashValue
            }
            if hasJsonName {
               hashCode = (hashCode &* 31) &+ jsonName.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.FieldDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.FieldDescriptorProto"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.FieldDescriptorProto = Google.Protobuf.FieldDescriptorProto()
      public func getMessage() -> Google.Protobuf.FieldDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      @discardableResult
      public func setName(_ value:String) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.name = value
        return self
      }
      @discardableResult
      public func clearName() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var hasNumber:Bool {
           get {
                return builderResult.hasNumber
           }
      }
      public var number:Int32 {
           get {
                return builderResult.number
           }
           set (value) {
               builderResult.hasNumber = true
               builderResult.number = value
           }
      }
      @discardableResult
      public func setNumber(_ value:Int32) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.number = value
        return self
      }
      @discardableResult
      public func clearNumber() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasNumber = false
           builderResult.number = Int32(0)
           return self
      }
        public var hasLabel:Bool{
            get {
                return builderResult.hasLabel
            }
        }
        public var label:Google.Protobuf.FieldDescriptorProto.Label {
            get {
                return builderResult.label
            }
            set (value) {
                builderResult.hasLabel = true
                builderResult.label = value
            }
        }
      @discardableResult
        public func setLabel(_ value:Google.Protobuf.FieldDescriptorProto.Label) -> Google.Protobuf.FieldDescriptorProto.Builder {
          self.label = value
          return self
        }
      @discardableResult
        public func clearLabel() -> Google.Protobuf.FieldDescriptorProto.Builder {
           builderResult.hasLabel = false
           builderResult.label = .labelOptional
           return self
        }
        public var hasType:Bool{
            get {
                return builderResult.hasType
            }
        }
        public var type:Google.Protobuf.FieldDescriptorProto.`Type` {
            get {
                return builderResult.type
            }
            set (value) {
                builderResult.hasType = true
                builderResult.type = value
            }
        }
      @discardableResult
        public func setType(_ value:Google.Protobuf.FieldDescriptorProto.`Type`) -> Google.Protobuf.FieldDescriptorProto.Builder {
          self.type = value
          return self
        }
      @discardableResult
        public func clearType() -> Google.Protobuf.FieldDescriptorProto.Builder {
           builderResult.hasType = false
           builderResult.type = .typeDouble
           return self
        }
      public var hasTypeName:Bool {
           get {
                return builderResult.hasTypeName
           }
      }
      public var typeName:String {
           get {
                return builderResult.typeName
           }
           set (value) {
               builderResult.hasTypeName = true
               builderResult.typeName = value
           }
      }
      @discardableResult
      public func setTypeName(_ value:String) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.typeName = value
        return self
      }
      @discardableResult
      public func clearTypeName() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasTypeName = false
           builderResult.typeName = ""
           return self
      }
      public var hasExtendee:Bool {
           get {
                return builderResult.hasExtendee
           }
      }
      public var extendee:String {
           get {
                return builderResult.extendee
           }
           set (value) {
               builderResult.hasExtendee = true
               builderResult.extendee = value
           }
      }
      @discardableResult
      public func setExtendee(_ value:String) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.extendee = value
        return self
      }
      @discardableResult
      public func clearExtendee() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasExtendee = false
           builderResult.extendee = ""
           return self
      }
      public var hasDefaultValue:Bool {
           get {
                return builderResult.hasDefaultValue
           }
      }
      public var defaultValue:String {
           get {
                return builderResult.defaultValue
           }
           set (value) {
               builderResult.hasDefaultValue = true
               builderResult.defaultValue = value
           }
      }
      @discardableResult
      public func setDefaultValue(_ value:String) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.defaultValue = value
        return self
      }
      @discardableResult
      public func clearDefaultValue() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasDefaultValue = false
           builderResult.defaultValue = ""
           return self
      }
      public var hasOneofIndex:Bool {
           get {
                return builderResult.hasOneofIndex
           }
      }
      public var oneofIndex:Int32 {
           get {
                return builderResult.oneofIndex
           }
           set (value) {
               builderResult.hasOneofIndex = true
               builderResult.oneofIndex = value
           }
      }
      @discardableResult
      public func setOneofIndex(_ value:Int32) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.oneofIndex = value
        return self
      }
      @discardableResult
      public func clearOneofIndex() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasOneofIndex = false
           builderResult.oneofIndex = Int32(0)
           return self
      }
      public var hasJsonName:Bool {
           get {
                return builderResult.hasJsonName
           }
      }
      public var jsonName:String {
           get {
                return builderResult.jsonName
           }
           set (value) {
               builderResult.hasJsonName = true
               builderResult.jsonName = value
           }
      }
      @discardableResult
      public func setJsonName(_ value:String) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.jsonName = value
        return self
      }
      @discardableResult
      public func clearJsonName() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasJsonName = false
           builderResult.jsonName = ""
           return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.FieldOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      fileprivate var optionsBuilder_:Google.Protobuf.FieldOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.FieldOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.FieldOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(other: options)
           }
        }
        return optionsBuilder_
      }
      @discardableResult
      public func setOptions(_ value:Google.Protobuf.FieldOptions!) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.options = value
        return self
      }
      @discardableResult
      public func mergeOptions(value:Google.Protobuf.FieldOptions) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.FieldOptions.builderWithPrototype(prototype:builderResult.options).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      @discardableResult
      public func clearOptions() -> Google.Protobuf.FieldDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.FieldDescriptorProto.Builder {
        builderResult = Google.Protobuf.FieldDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        return try Google.Protobuf.FieldDescriptorProto.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.FieldDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.FieldDescriptorProto {
        let returnMe:Google.Protobuf.FieldDescriptorProto = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.FieldDescriptorProto) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        if other == Google.Protobuf.FieldDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if other.hasNumber {
             number = other.number
        }
        if other.hasLabel {
             label = other.label
        }
        if other.hasType {
             type = other.type
        }
        if other.hasTypeName {
             typeName = other.typeName
        }
        if other.hasExtendee {
             extendee = other.extendee
        }
        if other.hasDefaultValue {
             defaultValue = other.defaultValue
        }
        if other.hasOneofIndex {
             oneofIndex = other.oneofIndex
        }
        if other.hasJsonName {
             jsonName = other.jsonName
        }
        if (other.hasOptions) {
            try mergeOptions(value: other.options)
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try codedInputStream.readString()

          case 18:
            extendee = try codedInputStream.readString()

          case 24:
            number = try codedInputStream.readInt32()

          case 32:
            let valueIntlabel = try codedInputStream.readEnum()
            if let enumslabel = Google.Protobuf.FieldDescriptorProto.Label(rawValue:valueIntlabel){
                 label = enumslabel
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntlabel))
            }

          case 40:
            let valueInttype = try codedInputStream.readEnum()
            if let enumstype = Google.Protobuf.FieldDescriptorProto.`Type`(rawValue:valueInttype){
                 type = enumstype
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueInttype))
            }

          case 50:
            typeName = try codedInputStream.readString()

          case 58:
            defaultValue = try codedInputStream.readString()

          case 66:
            let subBuilder:Google.Protobuf.FieldOptions.Builder = Google.Protobuf.FieldOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(other: options)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          case 72:
            oneofIndex = try codedInputStream.readInt32()

          case 82:
            jsonName = try codedInputStream.readString()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.FieldDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueNumber = jsonMap["number"] as? Int {
          resultDecodedBuilder.number = Int32(jsonValueNumber)
        }
        if let jsonValueLabel = jsonMap["label"] as? String {
          resultDecodedBuilder.label = try Google.Protobuf.FieldDescriptorProto.Label.fromString(str: jsonValueLabel)
        }
        if let jsonValueType = jsonMap["type"] as? String {
          resultDecodedBuilder.type = try Google.Protobuf.FieldDescriptorProto.`Type`.fromString(str: jsonValueType)
        }
        if let jsonValueTypeName = jsonMap["typeName"] as? String {
          resultDecodedBuilder.typeName = jsonValueTypeName
        }
        if let jsonValueExtendee = jsonMap["extendee"] as? String {
          resultDecodedBuilder.extendee = jsonValueExtendee
        }
        if let jsonValueDefaultValue = jsonMap["defaultValue"] as? String {
          resultDecodedBuilder.defaultValue = jsonValueDefaultValue
        }
        if let jsonValueOneofIndex = jsonMap["oneofIndex"] as? Int {
          resultDecodedBuilder.oneofIndex = Int32(jsonValueOneofIndex)
        }
        if let jsonValueJsonName = jsonMap["jsonName"] as? String {
          resultDecodedBuilder.jsonName = jsonValueJsonName
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,Any> {
          resultDecodedBuilder.options = try Google.Protobuf.FieldOptions.Builder.decodeToBuilder(jsonMap:jsonValueOptions).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.FieldDescriptorProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // Describes a oneof.
  final public class OneofDescriptorProto : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.OneofDescriptorProto, rhs: Google.Protobuf.OneofDescriptorProto) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
      fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var options:Google.Protobuf.OneofOptions!
    public fileprivate(set) var hasOptions:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasName {
        try codedOutputStream.writeString(fieldNumber: 1, value:name)
      }
      if hasOptions {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:options)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(fieldNumber: 1)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeoptions
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.OneofDescriptorProto.Builder {
      return Google.Protobuf.OneofDescriptorProto.classBuilder() as! Google.Protobuf.OneofDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.OneofDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.OneofDescriptorProto.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.OneofDescriptorProto.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.OneofDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.OneofDescriptorProto.Builder {
      return try Google.Protobuf.OneofDescriptorProto.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.OneofDescriptorProto) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
      return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasName {
        jsonMap["name"] = name
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.OneofDescriptorProto {
      return try Google.Protobuf.OneofDescriptorProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.OneofDescriptorProto {
      return try Google.Protobuf.OneofDescriptorProto.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.OneofDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.OneofDescriptorProto"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.OneofDescriptorProto = Google.Protobuf.OneofDescriptorProto()
      public func getMessage() -> Google.Protobuf.OneofDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      @discardableResult
      public func setName(_ value:String) -> Google.Protobuf.OneofDescriptorProto.Builder {
        self.name = value
        return self
      }
      @discardableResult
      public func clearName() -> Google.Protobuf.OneofDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.OneofOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      fileprivate var optionsBuilder_:Google.Protobuf.OneofOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.OneofOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.OneofOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(other: options)
           }
        }
        return optionsBuilder_
      }
      @discardableResult
      public func setOptions(_ value:Google.Protobuf.OneofOptions!) -> Google.Protobuf.OneofDescriptorProto.Builder {
        self.options = value
        return self
      }
      @discardableResult
      public func mergeOptions(value:Google.Protobuf.OneofOptions) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.OneofOptions.builderWithPrototype(prototype:builderResult.options).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      @discardableResult
      public func clearOptions() -> Google.Protobuf.OneofDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.OneofDescriptorProto.Builder {
        builderResult = Google.Protobuf.OneofDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.OneofDescriptorProto.Builder {
        return try Google.Protobuf.OneofDescriptorProto.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.OneofDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.OneofDescriptorProto {
        let returnMe:Google.Protobuf.OneofDescriptorProto = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.OneofDescriptorProto) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
        if other == Google.Protobuf.OneofDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if (other.hasOptions) {
            try mergeOptions(value: other.options)
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try codedInputStream.readString()

          case 18:
            let subBuilder:Google.Protobuf.OneofOptions.Builder = Google.Protobuf.OneofOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(other: options)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.OneofDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,Any> {
          resultDecodedBuilder.options = try Google.Protobuf.OneofOptions.Builder.decodeToBuilder(jsonMap:jsonValueOptions).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.OneofDescriptorProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // Describes an enum type.
  final public class EnumDescriptorProto : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.EnumDescriptorProto, rhs: Google.Protobuf.EnumDescriptorProto) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
      fieldCheck = fieldCheck && (lhs.value == rhs.value)
      fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var value:Array<Google.Protobuf.EnumValueDescriptorProto>  = Array<Google.Protobuf.EnumValueDescriptorProto>()
    public fileprivate(set) var options:Google.Protobuf.EnumOptions!
    public fileprivate(set) var hasOptions:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitValue:Bool = true
      for oneElementValue in value {
        if !oneElementValue.isInitialized() {
          isInitValue = false
          break 
        }
      }
      if !isInitValue {
        return isInitValue
      }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasName {
        try codedOutputStream.writeString(fieldNumber: 1, value:name)
      }
      for oneElementValue in value {
          try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementValue)
      }
      if hasOptions {
        try codedOutputStream.writeMessage(fieldNumber: 3, value:options)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(fieldNumber: 1)
      }
      for oneElementValue in value {
          serialize_size += oneElementValue.computeMessageSize(fieldNumber: 2)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(fieldNumber: 3) {
              serialize_size += varSizeoptions
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.EnumDescriptorProto.Builder {
      return Google.Protobuf.EnumDescriptorProto.classBuilder() as! Google.Protobuf.EnumDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.EnumDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.EnumDescriptorProto.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.EnumDescriptorProto.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.EnumDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.EnumDescriptorProto.Builder {
      return try Google.Protobuf.EnumDescriptorProto.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.EnumDescriptorProto) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
      return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasName {
        jsonMap["name"] = name
      }
      if !value.isEmpty {
        var jsonArrayValue:Array<Dictionary<String,Any>> = []
          for oneValueValue in value {
            let ecodedMessageValue = try oneValueValue.encode()
            jsonArrayValue.append(ecodedMessageValue)
          }
        jsonMap["value"] = jsonArrayValue
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.EnumDescriptorProto {
      return try Google.Protobuf.EnumDescriptorProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.EnumDescriptorProto {
      return try Google.Protobuf.EnumDescriptorProto.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var valueElementIndex:Int = 0
      for oneElementValue in value {
          output += "\(indent) value[\(valueElementIndex)] {\n"
          output += try oneElementValue.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          valueElementIndex += 1
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneElementValue in value {
                hashCode = (hashCode &* 31) &+ oneElementValue.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.EnumDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.EnumDescriptorProto"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.EnumDescriptorProto = Google.Protobuf.EnumDescriptorProto()
      public func getMessage() -> Google.Protobuf.EnumDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      @discardableResult
      public func setName(_ value:String) -> Google.Protobuf.EnumDescriptorProto.Builder {
        self.name = value
        return self
      }
      @discardableResult
      public func clearName() -> Google.Protobuf.EnumDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var value:Array<Google.Protobuf.EnumValueDescriptorProto> {
           get {
               return builderResult.value
           }
           set (value) {
               builderResult.value = value
           }
      }
      @discardableResult
      public func setValue(_ value:Array<Google.Protobuf.EnumValueDescriptorProto>) -> Google.Protobuf.EnumDescriptorProto.Builder {
        self.value = value
        return self
      }
      @discardableResult
      public func clearValue() -> Google.Protobuf.EnumDescriptorProto.Builder {
        builderResult.value.removeAll(keepingCapacity: false)
        return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.EnumOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      fileprivate var optionsBuilder_:Google.Protobuf.EnumOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.EnumOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.EnumOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(other: options)
           }
        }
        return optionsBuilder_
      }
      @discardableResult
      public func setOptions(_ value:Google.Protobuf.EnumOptions!) -> Google.Protobuf.EnumDescriptorProto.Builder {
        self.options = value
        return self
      }
      @discardableResult
      public func mergeOptions(value:Google.Protobuf.EnumOptions) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.EnumOptions.builderWithPrototype(prototype:builderResult.options).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      @discardableResult
      public func clearOptions() -> Google.Protobuf.EnumDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.EnumDescriptorProto.Builder {
        builderResult = Google.Protobuf.EnumDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        return try Google.Protobuf.EnumDescriptorProto.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.EnumDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.EnumDescriptorProto {
        let returnMe:Google.Protobuf.EnumDescriptorProto = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.EnumDescriptorProto) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        if other == Google.Protobuf.EnumDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if !other.value.isEmpty  {
           builderResult.value += other.value
        }
        if (other.hasOptions) {
            try mergeOptions(value: other.options)
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try codedInputStream.readString()

          case 18:
            let subBuilder = Google.Protobuf.EnumValueDescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            value.append(subBuilder.buildPartial())

          case 26:
            let subBuilder:Google.Protobuf.EnumOptions.Builder = Google.Protobuf.EnumOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(other: options)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.EnumDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueValue = jsonMap["value"] as? Array<Dictionary<String,Any>> {
          var jsonArrayValue:Array<Google.Protobuf.EnumValueDescriptorProto> = []
          for oneValueValue in jsonValueValue {
            let messageFromStringValue = try Google.Protobuf.EnumValueDescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueValue).build()

            jsonArrayValue.append(messageFromStringValue)
          }
          resultDecodedBuilder.value = jsonArrayValue
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,Any> {
          resultDecodedBuilder.options = try Google.Protobuf.EnumOptions.Builder.decodeToBuilder(jsonMap:jsonValueOptions).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.EnumDescriptorProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // Describes a value within an enum.
  final public class EnumValueDescriptorProto : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.EnumValueDescriptorProto, rhs: Google.Protobuf.EnumValueDescriptorProto) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
      fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
      fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var number:Int32 = Int32(0)
    public fileprivate(set) var hasNumber:Bool = false

    public fileprivate(set) var options:Google.Protobuf.EnumValueOptions!
    public fileprivate(set) var hasOptions:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasName {
        try codedOutputStream.writeString(fieldNumber: 1, value:name)
      }
      if hasNumber {
        try codedOutputStream.writeInt32(fieldNumber: 2, value:number)
      }
      if hasOptions {
        try codedOutputStream.writeMessage(fieldNumber: 3, value:options)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(fieldNumber: 1)
      }
      if hasNumber {
        serialize_size += number.computeInt32Size(fieldNumber: 2)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(fieldNumber: 3) {
              serialize_size += varSizeoptions
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.EnumValueDescriptorProto.Builder {
      return Google.Protobuf.EnumValueDescriptorProto.classBuilder() as! Google.Protobuf.EnumValueDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.EnumValueDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.EnumValueDescriptorProto.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.EnumValueDescriptorProto.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.EnumValueDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
      return try Google.Protobuf.EnumValueDescriptorProto.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.EnumValueDescriptorProto) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasName {
        jsonMap["name"] = name
      }
      if hasNumber {
        jsonMap["number"] = Int(number)
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.EnumValueDescriptorProto {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.EnumValueDescriptorProto {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasNumber {
        output += "\(indent) number: \(number) \n"
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasNumber {
               hashCode = (hashCode &* 31) &+ number.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.EnumValueDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.EnumValueDescriptorProto"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.EnumValueDescriptorProto = Google.Protobuf.EnumValueDescriptorProto()
      public func getMessage() -> Google.Protobuf.EnumValueDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      @discardableResult
      public func setName(_ value:String) -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        self.name = value
        return self
      }
      @discardableResult
      public func clearName() -> Google.Protobuf.EnumValueDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var hasNumber:Bool {
           get {
                return builderResult.hasNumber
           }
      }
      public var number:Int32 {
           get {
                return builderResult.number
           }
           set (value) {
               builderResult.hasNumber = true
               builderResult.number = value
           }
      }
      @discardableResult
      public func setNumber(_ value:Int32) -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        self.number = value
        return self
      }
      @discardableResult
      public func clearNumber() -> Google.Protobuf.EnumValueDescriptorProto.Builder{
           builderResult.hasNumber = false
           builderResult.number = Int32(0)
           return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.EnumValueOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      fileprivate var optionsBuilder_:Google.Protobuf.EnumValueOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.EnumValueOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.EnumValueOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(other: options)
           }
        }
        return optionsBuilder_
      }
      @discardableResult
      public func setOptions(_ value:Google.Protobuf.EnumValueOptions!) -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        self.options = value
        return self
      }
      @discardableResult
      public func mergeOptions(value:Google.Protobuf.EnumValueOptions) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.EnumValueOptions.builderWithPrototype(prototype:builderResult.options).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      @discardableResult
      public func clearOptions() -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        builderResult = Google.Protobuf.EnumValueDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        return try Google.Protobuf.EnumValueDescriptorProto.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.EnumValueDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.EnumValueDescriptorProto {
        let returnMe:Google.Protobuf.EnumValueDescriptorProto = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.EnumValueDescriptorProto) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        if other == Google.Protobuf.EnumValueDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if other.hasNumber {
             number = other.number
        }
        if (other.hasOptions) {
            try mergeOptions(value: other.options)
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try codedInputStream.readString()

          case 16:
            number = try codedInputStream.readInt32()

          case 26:
            let subBuilder:Google.Protobuf.EnumValueOptions.Builder = Google.Protobuf.EnumValueOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(other: options)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.EnumValueDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueNumber = jsonMap["number"] as? Int {
          resultDecodedBuilder.number = Int32(jsonValueNumber)
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,Any> {
          resultDecodedBuilder.options = try Google.Protobuf.EnumValueOptions.Builder.decodeToBuilder(jsonMap:jsonValueOptions).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.EnumValueDescriptorProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // Describes a service.
  final public class ServiceDescriptorProto : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.ServiceDescriptorProto, rhs: Google.Protobuf.ServiceDescriptorProto) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
      fieldCheck = fieldCheck && (lhs.method == rhs.method)
      fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var method:Array<Google.Protobuf.MethodDescriptorProto>  = Array<Google.Protobuf.MethodDescriptorProto>()
    public fileprivate(set) var options:Google.Protobuf.ServiceOptions!
    public fileprivate(set) var hasOptions:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitMethod:Bool = true
      for oneElementMethod in method {
        if !oneElementMethod.isInitialized() {
          isInitMethod = false
          break 
        }
      }
      if !isInitMethod {
        return isInitMethod
      }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasName {
        try codedOutputStream.writeString(fieldNumber: 1, value:name)
      }
      for oneElementMethod in method {
          try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementMethod)
      }
      if hasOptions {
        try codedOutputStream.writeMessage(fieldNumber: 3, value:options)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(fieldNumber: 1)
      }
      for oneElementMethod in method {
          serialize_size += oneElementMethod.computeMessageSize(fieldNumber: 2)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(fieldNumber: 3) {
              serialize_size += varSizeoptions
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.ServiceDescriptorProto.Builder {
      return Google.Protobuf.ServiceDescriptorProto.classBuilder() as! Google.Protobuf.ServiceDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.ServiceDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.ServiceDescriptorProto.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.ServiceDescriptorProto.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.ServiceDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
      return try Google.Protobuf.ServiceDescriptorProto.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.ServiceDescriptorProto) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
      return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasName {
        jsonMap["name"] = name
      }
      if !method.isEmpty {
        var jsonArrayMethod:Array<Dictionary<String,Any>> = []
          for oneValueMethod in method {
            let ecodedMessageMethod = try oneValueMethod.encode()
            jsonArrayMethod.append(ecodedMessageMethod)
          }
        jsonMap["method"] = jsonArrayMethod
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.ServiceDescriptorProto {
      return try Google.Protobuf.ServiceDescriptorProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.ServiceDescriptorProto {
      return try Google.Protobuf.ServiceDescriptorProto.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var methodElementIndex:Int = 0
      for oneElementMethod in method {
          output += "\(indent) method[\(methodElementIndex)] {\n"
          output += try oneElementMethod.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          methodElementIndex += 1
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneElementMethod in method {
                hashCode = (hashCode &* 31) &+ oneElementMethod.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.ServiceDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.ServiceDescriptorProto"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.ServiceDescriptorProto = Google.Protobuf.ServiceDescriptorProto()
      public func getMessage() -> Google.Protobuf.ServiceDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      @discardableResult
      public func setName(_ value:String) -> Google.Protobuf.ServiceDescriptorProto.Builder {
        self.name = value
        return self
      }
      @discardableResult
      public func clearName() -> Google.Protobuf.ServiceDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var method:Array<Google.Protobuf.MethodDescriptorProto> {
           get {
               return builderResult.method
           }
           set (value) {
               builderResult.method = value
           }
      }
      @discardableResult
      public func setMethod(_ value:Array<Google.Protobuf.MethodDescriptorProto>) -> Google.Protobuf.ServiceDescriptorProto.Builder {
        self.method = value
        return self
      }
      @discardableResult
      public func clearMethod() -> Google.Protobuf.ServiceDescriptorProto.Builder {
        builderResult.method.removeAll(keepingCapacity: false)
        return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.ServiceOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      fileprivate var optionsBuilder_:Google.Protobuf.ServiceOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.ServiceOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.ServiceOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(other: options)
           }
        }
        return optionsBuilder_
      }
      @discardableResult
      public func setOptions(_ value:Google.Protobuf.ServiceOptions!) -> Google.Protobuf.ServiceDescriptorProto.Builder {
        self.options = value
        return self
      }
      @discardableResult
      public func mergeOptions(value:Google.Protobuf.ServiceOptions) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.ServiceOptions.builderWithPrototype(prototype:builderResult.options).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      @discardableResult
      public func clearOptions() -> Google.Protobuf.ServiceDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.ServiceDescriptorProto.Builder {
        builderResult = Google.Protobuf.ServiceDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        return try Google.Protobuf.ServiceDescriptorProto.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.ServiceDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.ServiceDescriptorProto {
        let returnMe:Google.Protobuf.ServiceDescriptorProto = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.ServiceDescriptorProto) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        if other == Google.Protobuf.ServiceDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if !other.method.isEmpty  {
           builderResult.method += other.method
        }
        if (other.hasOptions) {
            try mergeOptions(value: other.options)
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try codedInputStream.readString()

          case 18:
            let subBuilder = Google.Protobuf.MethodDescriptorProto.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            method.append(subBuilder.buildPartial())

          case 26:
            let subBuilder:Google.Protobuf.ServiceOptions.Builder = Google.Protobuf.ServiceOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(other: options)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.ServiceDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueMethod = jsonMap["method"] as? Array<Dictionary<String,Any>> {
          var jsonArrayMethod:Array<Google.Protobuf.MethodDescriptorProto> = []
          for oneValueMethod in jsonValueMethod {
            let messageFromStringMethod = try Google.Protobuf.MethodDescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueMethod).build()

            jsonArrayMethod.append(messageFromStringMethod)
          }
          resultDecodedBuilder.method = jsonArrayMethod
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,Any> {
          resultDecodedBuilder.options = try Google.Protobuf.ServiceOptions.Builder.decodeToBuilder(jsonMap:jsonValueOptions).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.ServiceDescriptorProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // Describes a method of a service.
  final public class MethodDescriptorProto : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.MethodDescriptorProto, rhs: Google.Protobuf.MethodDescriptorProto) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
      fieldCheck = fieldCheck && (lhs.hasInputType == rhs.hasInputType) && (!lhs.hasInputType || lhs.inputType == rhs.inputType)
      fieldCheck = fieldCheck && (lhs.hasOutputType == rhs.hasOutputType) && (!lhs.hasOutputType || lhs.outputType == rhs.outputType)
      fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
      fieldCheck = fieldCheck && (lhs.hasClientStreaming == rhs.hasClientStreaming) && (!lhs.hasClientStreaming || lhs.clientStreaming == rhs.clientStreaming)
      fieldCheck = fieldCheck && (lhs.hasServerStreaming == rhs.hasServerStreaming) && (!lhs.hasServerStreaming || lhs.serverStreaming == rhs.serverStreaming)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    // Input and output type names.  These are resolved in the same way as
    // FieldDescriptorProto.type_name, but must refer to a message type.
    public fileprivate(set) var inputType:String = ""
    public fileprivate(set) var hasInputType:Bool = false

    public fileprivate(set) var outputType:String = ""
    public fileprivate(set) var hasOutputType:Bool = false

    public fileprivate(set) var options:Google.Protobuf.MethodOptions!
    public fileprivate(set) var hasOptions:Bool = false
    // Identifies if client streams multiple client messages
    public fileprivate(set) var clientStreaming:Bool = false
    public fileprivate(set) var hasClientStreaming:Bool = false

    // Identifies if server streams multiple server messages
    public fileprivate(set) var serverStreaming:Bool = false
    public fileprivate(set) var hasServerStreaming:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasName {
        try codedOutputStream.writeString(fieldNumber: 1, value:name)
      }
      if hasInputType {
        try codedOutputStream.writeString(fieldNumber: 2, value:inputType)
      }
      if hasOutputType {
        try codedOutputStream.writeString(fieldNumber: 3, value:outputType)
      }
      if hasOptions {
        try codedOutputStream.writeMessage(fieldNumber: 4, value:options)
      }
      if hasClientStreaming {
        try codedOutputStream.writeBool(fieldNumber: 5, value:clientStreaming)
      }
      if hasServerStreaming {
        try codedOutputStream.writeBool(fieldNumber: 6, value:serverStreaming)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(fieldNumber: 1)
      }
      if hasInputType {
        serialize_size += inputType.computeStringSize(fieldNumber: 2)
      }
      if hasOutputType {
        serialize_size += outputType.computeStringSize(fieldNumber: 3)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(fieldNumber: 4) {
              serialize_size += varSizeoptions
          }
      }
      if hasClientStreaming {
        serialize_size += clientStreaming.computeBoolSize(fieldNumber: 5)
      }
      if hasServerStreaming {
        serialize_size += serverStreaming.computeBoolSize(fieldNumber: 6)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.MethodDescriptorProto.Builder {
      return Google.Protobuf.MethodDescriptorProto.classBuilder() as! Google.Protobuf.MethodDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.MethodDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.MethodDescriptorProto.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.MethodDescriptorProto.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.MethodDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.MethodDescriptorProto.Builder {
      return try Google.Protobuf.MethodDescriptorProto.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.MethodDescriptorProto) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
      return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasName {
        jsonMap["name"] = name
      }
      if hasInputType {
        jsonMap["inputType"] = inputType
      }
      if hasOutputType {
        jsonMap["outputType"] = outputType
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      if hasClientStreaming {
        jsonMap["clientStreaming"] = clientStreaming
      }
      if hasServerStreaming {
        jsonMap["serverStreaming"] = serverStreaming
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.MethodDescriptorProto {
      return try Google.Protobuf.MethodDescriptorProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.MethodDescriptorProto {
      return try Google.Protobuf.MethodDescriptorProto.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasInputType {
        output += "\(indent) inputType: \(inputType) \n"
      }
      if hasOutputType {
        output += "\(indent) outputType: \(outputType) \n"
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasClientStreaming {
        output += "\(indent) clientStreaming: \(clientStreaming) \n"
      }
      if hasServerStreaming {
        output += "\(indent) serverStreaming: \(serverStreaming) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasInputType {
               hashCode = (hashCode &* 31) &+ inputType.hashValue
            }
            if hasOutputType {
               hashCode = (hashCode &* 31) &+ outputType.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            if hasClientStreaming {
               hashCode = (hashCode &* 31) &+ clientStreaming.hashValue
            }
            if hasServerStreaming {
               hashCode = (hashCode &* 31) &+ serverStreaming.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.MethodDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.MethodDescriptorProto"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.MethodDescriptorProto = Google.Protobuf.MethodDescriptorProto()
      public func getMessage() -> Google.Protobuf.MethodDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      @discardableResult
      public func setName(_ value:String) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.name = value
        return self
      }
      @discardableResult
      public func clearName() -> Google.Protobuf.MethodDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var hasInputType:Bool {
           get {
                return builderResult.hasInputType
           }
      }
      public var inputType:String {
           get {
                return builderResult.inputType
           }
           set (value) {
               builderResult.hasInputType = true
               builderResult.inputType = value
           }
      }
      @discardableResult
      public func setInputType(_ value:String) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.inputType = value
        return self
      }
      @discardableResult
      public func clearInputType() -> Google.Protobuf.MethodDescriptorProto.Builder{
           builderResult.hasInputType = false
           builderResult.inputType = ""
           return self
      }
      public var hasOutputType:Bool {
           get {
                return builderResult.hasOutputType
           }
      }
      public var outputType:String {
           get {
                return builderResult.outputType
           }
           set (value) {
               builderResult.hasOutputType = true
               builderResult.outputType = value
           }
      }
      @discardableResult
      public func setOutputType(_ value:String) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.outputType = value
        return self
      }
      @discardableResult
      public func clearOutputType() -> Google.Protobuf.MethodDescriptorProto.Builder{
           builderResult.hasOutputType = false
           builderResult.outputType = ""
           return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.MethodOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      fileprivate var optionsBuilder_:Google.Protobuf.MethodOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.MethodOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.MethodOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(other: options)
           }
        }
        return optionsBuilder_
      }
      @discardableResult
      public func setOptions(_ value:Google.Protobuf.MethodOptions!) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.options = value
        return self
      }
      @discardableResult
      public func mergeOptions(value:Google.Protobuf.MethodOptions) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.MethodOptions.builderWithPrototype(prototype:builderResult.options).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      @discardableResult
      public func clearOptions() -> Google.Protobuf.MethodDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      public var hasClientStreaming:Bool {
           get {
                return builderResult.hasClientStreaming
           }
      }
      public var clientStreaming:Bool {
           get {
                return builderResult.clientStreaming
           }
           set (value) {
               builderResult.hasClientStreaming = true
               builderResult.clientStreaming = value
           }
      }
      @discardableResult
      public func setClientStreaming(_ value:Bool) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.clientStreaming = value
        return self
      }
      @discardableResult
      public func clearClientStreaming() -> Google.Protobuf.MethodDescriptorProto.Builder{
           builderResult.hasClientStreaming = false
           builderResult.clientStreaming = false
           return self
      }
      public var hasServerStreaming:Bool {
           get {
                return builderResult.hasServerStreaming
           }
      }
      public var serverStreaming:Bool {
           get {
                return builderResult.serverStreaming
           }
           set (value) {
               builderResult.hasServerStreaming = true
               builderResult.serverStreaming = value
           }
      }
      @discardableResult
      public func setServerStreaming(_ value:Bool) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.serverStreaming = value
        return self
      }
      @discardableResult
      public func clearServerStreaming() -> Google.Protobuf.MethodDescriptorProto.Builder{
           builderResult.hasServerStreaming = false
           builderResult.serverStreaming = false
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.MethodDescriptorProto.Builder {
        builderResult = Google.Protobuf.MethodDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        return try Google.Protobuf.MethodDescriptorProto.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.MethodDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.MethodDescriptorProto {
        let returnMe:Google.Protobuf.MethodDescriptorProto = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.MethodDescriptorProto) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        if other == Google.Protobuf.MethodDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if other.hasInputType {
             inputType = other.inputType
        }
        if other.hasOutputType {
             outputType = other.outputType
        }
        if (other.hasOptions) {
            try mergeOptions(value: other.options)
        }
        if other.hasClientStreaming {
             clientStreaming = other.clientStreaming
        }
        if other.hasServerStreaming {
             serverStreaming = other.serverStreaming
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try codedInputStream.readString()

          case 18:
            inputType = try codedInputStream.readString()

          case 26:
            outputType = try codedInputStream.readString()

          case 34:
            let subBuilder:Google.Protobuf.MethodOptions.Builder = Google.Protobuf.MethodOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(other: options)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          case 40:
            clientStreaming = try codedInputStream.readBool()

          case 48:
            serverStreaming = try codedInputStream.readBool()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.MethodDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueInputType = jsonMap["inputType"] as? String {
          resultDecodedBuilder.inputType = jsonValueInputType
        }
        if let jsonValueOutputType = jsonMap["outputType"] as? String {
          resultDecodedBuilder.outputType = jsonValueOutputType
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,Any> {
          resultDecodedBuilder.options = try Google.Protobuf.MethodOptions.Builder.decodeToBuilder(jsonMap:jsonValueOptions).build()

        }
        if let jsonValueClientStreaming = jsonMap["clientStreaming"] as? Bool {
          resultDecodedBuilder.clientStreaming = jsonValueClientStreaming
        }
        if let jsonValueServerStreaming = jsonMap["serverStreaming"] as? Bool {
          resultDecodedBuilder.serverStreaming = jsonValueServerStreaming
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.MethodDescriptorProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class FileOptions : ExtendableMessage {

    public static func == (lhs: Google.Protobuf.FileOptions, rhs: Google.Protobuf.FileOptions) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasJavaPackage == rhs.hasJavaPackage) && (!lhs.hasJavaPackage || lhs.javaPackage == rhs.javaPackage)
      fieldCheck = fieldCheck && (lhs.hasJavaOuterClassname == rhs.hasJavaOuterClassname) && (!lhs.hasJavaOuterClassname || lhs.javaOuterClassname == rhs.javaOuterClassname)
      fieldCheck = fieldCheck && (lhs.hasOptimizeFor == rhs.hasOptimizeFor) && (!lhs.hasOptimizeFor || lhs.optimizeFor == rhs.optimizeFor)
      fieldCheck = fieldCheck && (lhs.hasJavaMultipleFiles == rhs.hasJavaMultipleFiles) && (!lhs.hasJavaMultipleFiles || lhs.javaMultipleFiles == rhs.javaMultipleFiles)
      fieldCheck = fieldCheck && (lhs.hasGoPackage == rhs.hasGoPackage) && (!lhs.hasGoPackage || lhs.goPackage == rhs.goPackage)
      fieldCheck = fieldCheck && (lhs.hasCcGenericServices == rhs.hasCcGenericServices) && (!lhs.hasCcGenericServices || lhs.ccGenericServices == rhs.ccGenericServices)
      fieldCheck = fieldCheck && (lhs.hasJavaGenericServices == rhs.hasJavaGenericServices) && (!lhs.hasJavaGenericServices || lhs.javaGenericServices == rhs.javaGenericServices)
      fieldCheck = fieldCheck && (lhs.hasPyGenericServices == rhs.hasPyGenericServices) && (!lhs.hasPyGenericServices || lhs.pyGenericServices == rhs.pyGenericServices)
      fieldCheck = fieldCheck && (lhs.hasJavaGenerateEqualsAndHash == rhs.hasJavaGenerateEqualsAndHash) && (!lhs.hasJavaGenerateEqualsAndHash || lhs.javaGenerateEqualsAndHash == rhs.javaGenerateEqualsAndHash)
      fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
      fieldCheck = fieldCheck && (lhs.hasJavaStringCheckUtf8 == rhs.hasJavaStringCheckUtf8) && (!lhs.hasJavaStringCheckUtf8 || lhs.javaStringCheckUtf8 == rhs.javaStringCheckUtf8)
      fieldCheck = fieldCheck && (lhs.hasCcEnableArenas == rhs.hasCcEnableArenas) && (!lhs.hasCcEnableArenas || lhs.ccEnableArenas == rhs.ccEnableArenas)
      fieldCheck = fieldCheck && (lhs.hasObjcClassPrefix == rhs.hasObjcClassPrefix) && (!lhs.hasObjcClassPrefix || lhs.objcClassPrefix == rhs.objcClassPrefix)
      fieldCheck = fieldCheck && (lhs.hasCsharpNamespace == rhs.hasCsharpNamespace) && (!lhs.hasCsharpNamespace || lhs.csharpNamespace == rhs.csharpNamespace)
      fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
      fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:536870912)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      // Generated classes can be optimized for speed or code size.
      public enum OptimizeMode:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // Generate complete code for parsing, serialization,
        case speed = 1

        // etc.
        case codeSize = 2

        // Generate code using MessageLite and the lite runtime.
        case liteRuntime = 3
        public func toString() -> String {
          switch self {
          case .speed: return "SPEED"
          case .codeSize: return "CODE_SIZE"
          case .liteRuntime: return "LITE_RUNTIME"
          }
        }
        public static func fromString(str:String) throws -> Google.Protobuf.FileOptions.OptimizeMode {
          switch str {
          case "SPEED":  return .speed
          case "CODE_SIZE":  return .codeSize
          case "LITE_RUNTIME":  return .liteRuntime
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .speed: return ".speed"
          case .codeSize: return ".codeSize"
          case .liteRuntime: return ".liteRuntime"
          }
        }
      }

      //Enum type declaration end 

    // Sets the Java package where classes generated from this .proto will be
    // placed.  By default, the proto package is used, but this is often
    // inappropriate because proto packages do not normally start with backwards
    // domain names.
    public fileprivate(set) var javaPackage:String = ""
    public fileprivate(set) var hasJavaPackage:Bool = false

    // If set, all the classes from the .proto file are wrapped in a single
    // outer class with the given name.  This applies to both Proto1
    // (equivalent to the old "--one_java_file" option) and Proto2 (where
    // a .proto always translates to a single class, but you may want to
    // explicitly choose the class name).
    public fileprivate(set) var javaOuterClassname:String = ""
    public fileprivate(set) var hasJavaOuterClassname:Bool = false

    // If set true, then the Java code generator will generate a separate .java
    // file for each top-level message, enum, and service defined in the .proto
    // file.  Thus, these types will *not* be nested inside the outer class
    // named by java_outer_classname.  However, the outer class will still be
    // generated to contain the file's getDescriptor() method as well as any
    // top-level extensions defined in the file.
    public fileprivate(set) var javaMultipleFiles:Bool = false
    public fileprivate(set) var hasJavaMultipleFiles:Bool = false

    @available(*, deprecated:0.1, message:"The field is marked as \"Deprecated\"")
    // This option does nothing.
    public fileprivate(set) var javaGenerateEqualsAndHash:Bool = false
    public fileprivate(set) var hasJavaGenerateEqualsAndHash:Bool = false

    // If set true, then the Java2 code generator will generate code that
    // throws an exception whenever an attempt is made to assign a non-UTF-8
    // byte sequence to a string field.
    // Message reflection will do the same.
    // However, an extension field still accepts non-UTF-8 byte sequences.
    // This option has no effect on when used with the lite runtime.
    public fileprivate(set) var javaStringCheckUtf8:Bool = false
    public fileprivate(set) var hasJavaStringCheckUtf8:Bool = false

    public fileprivate(set) var optimizeFor:Google.Protobuf.FileOptions.OptimizeMode = Google.Protobuf.FileOptions.OptimizeMode.speed
    public fileprivate(set) var hasOptimizeFor:Bool = false
    // Sets the Go package where structs generated from this .proto will be
    // placed. If omitted, the Go package will be derived from the following:
    //   - The basename of the package import path, if provided.
    //   - Otherwise, the package statement in the .proto file, if present.
    //   - Otherwise, the basename of the .proto file, without extension.
    public fileprivate(set) var goPackage:String = ""
    public fileprivate(set) var hasGoPackage:Bool = false

    // Should generic services be generated in each language?  "Generic" services
    // are not specific to any particular RPC system.  They are generated by the
    // main code generators in each language (without additional plugins).
    // Generic services were the only kind of service generation supported by
    // early versions of google.protobuf.
    // Generic services are now considered deprecated in favor of using plugins
    // that generate code specific to your particular RPC system.  Therefore,
    // these default to false.  Old code which depends on generic services should
    // explicitly set them to true.
    public fileprivate(set) var ccGenericServices:Bool = false
    public fileprivate(set) var hasCcGenericServices:Bool = false

    public fileprivate(set) var javaGenericServices:Bool = false
    public fileprivate(set) var hasJavaGenericServices:Bool = false

    public fileprivate(set) var pyGenericServices:Bool = false
    public fileprivate(set) var hasPyGenericServices:Bool = false

    // Is this file deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for everything in the file, or it will be completely ignored; in the very
    // least, this is a formalization for deprecating files.
    public fileprivate(set) var deprecated:Bool = false
    public fileprivate(set) var hasDeprecated:Bool = false

    // Enables the use of arenas for the proto messages in this file. This applies
    // only to generated classes for C++.
    public fileprivate(set) var ccEnableArenas:Bool = false
    public fileprivate(set) var hasCcEnableArenas:Bool = false

    // Sets the objective c class prefix which is prepended to all objective c
    // generated classes from this .proto. There is no default.
    public fileprivate(set) var objcClassPrefix:String = ""
    public fileprivate(set) var hasObjcClassPrefix:Bool = false

    // Namespace for generated classes; defaults to the package.
    public fileprivate(set) var csharpNamespace:String = ""
    public fileprivate(set) var hasCsharpNamespace:Bool = false

    public fileprivate(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasJavaPackage {
        try codedOutputStream.writeString(fieldNumber: 1, value:javaPackage)
      }
      if hasJavaOuterClassname {
        try codedOutputStream.writeString(fieldNumber: 8, value:javaOuterClassname)
      }
      if hasOptimizeFor {
        try codedOutputStream.writeEnum(fieldNumber: 9, value:optimizeFor.rawValue)
      }
      if hasJavaMultipleFiles {
        try codedOutputStream.writeBool(fieldNumber: 10, value:javaMultipleFiles)
      }
      if hasGoPackage {
        try codedOutputStream.writeString(fieldNumber: 11, value:goPackage)
      }
      if hasCcGenericServices {
        try codedOutputStream.writeBool(fieldNumber: 16, value:ccGenericServices)
      }
      if hasJavaGenericServices {
        try codedOutputStream.writeBool(fieldNumber: 17, value:javaGenericServices)
      }
      if hasPyGenericServices {
        try codedOutputStream.writeBool(fieldNumber: 18, value:pyGenericServices)
      }
      if hasJavaGenerateEqualsAndHash {
        try codedOutputStream.writeBool(fieldNumber: 20, value:javaGenerateEqualsAndHash)
      }
      if hasDeprecated {
        try codedOutputStream.writeBool(fieldNumber: 23, value:deprecated)
      }
      if hasJavaStringCheckUtf8 {
        try codedOutputStream.writeBool(fieldNumber: 27, value:javaStringCheckUtf8)
      }
      if hasCcEnableArenas {
        try codedOutputStream.writeBool(fieldNumber: 31, value:ccEnableArenas)
      }
      if hasObjcClassPrefix {
        try codedOutputStream.writeString(fieldNumber: 36, value:objcClassPrefix)
      }
      if hasCsharpNamespace {
        try codedOutputStream.writeString(fieldNumber: 37, value:csharpNamespace)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try codedOutputStream.writeMessage(fieldNumber: 999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:536870912)
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasJavaPackage {
        serialize_size += javaPackage.computeStringSize(fieldNumber: 1)
      }
      if hasJavaOuterClassname {
        serialize_size += javaOuterClassname.computeStringSize(fieldNumber: 8)
      }
      if (hasOptimizeFor) {
        serialize_size += optimizeFor.rawValue.computeEnumSize(fieldNumber: 9)
      }
      if hasJavaMultipleFiles {
        serialize_size += javaMultipleFiles.computeBoolSize(fieldNumber: 10)
      }
      if hasGoPackage {
        serialize_size += goPackage.computeStringSize(fieldNumber: 11)
      }
      if hasCcGenericServices {
        serialize_size += ccGenericServices.computeBoolSize(fieldNumber: 16)
      }
      if hasJavaGenericServices {
        serialize_size += javaGenericServices.computeBoolSize(fieldNumber: 17)
      }
      if hasPyGenericServices {
        serialize_size += pyGenericServices.computeBoolSize(fieldNumber: 18)
      }
      if hasJavaGenerateEqualsAndHash {
        serialize_size += javaGenerateEqualsAndHash.computeBoolSize(fieldNumber: 20)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(fieldNumber: 23)
      }
      if hasJavaStringCheckUtf8 {
        serialize_size += javaStringCheckUtf8.computeBoolSize(fieldNumber: 27)
      }
      if hasCcEnableArenas {
        serialize_size += ccEnableArenas.computeBoolSize(fieldNumber: 31)
      }
      if hasObjcClassPrefix {
        serialize_size += objcClassPrefix.computeStringSize(fieldNumber: 36)
      }
      if hasCsharpNamespace {
        serialize_size += csharpNamespace.computeStringSize(fieldNumber: 37)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(fieldNumber: 999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.FileOptions.Builder {
      return Google.Protobuf.FileOptions.classBuilder() as! Google.Protobuf.FileOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.FileOptions.Builder {
      return classBuilder() as! Google.Protobuf.FileOptions.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.FileOptions.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.FileOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.FileOptions.Builder {
      return try Google.Protobuf.FileOptions.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.FileOptions) throws -> Google.Protobuf.FileOptions.Builder {
      return try Google.Protobuf.FileOptions.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasJavaPackage {
        jsonMap["javaPackage"] = javaPackage
      }
      if hasJavaOuterClassname {
        jsonMap["javaOuterClassname"] = javaOuterClassname
      }
      if hasJavaMultipleFiles {
        jsonMap["javaMultipleFiles"] = javaMultipleFiles
      }
      if hasJavaGenerateEqualsAndHash {
        jsonMap["javaGenerateEqualsAndHash"] = javaGenerateEqualsAndHash
      }
      if hasJavaStringCheckUtf8 {
        jsonMap["javaStringCheckUtf8"] = javaStringCheckUtf8
      }
      if hasOptimizeFor {
        jsonMap["optimizeFor"] = optimizeFor.toString()
      }
      if hasGoPackage {
        jsonMap["goPackage"] = goPackage
      }
      if hasCcGenericServices {
        jsonMap["ccGenericServices"] = ccGenericServices
      }
      if hasJavaGenericServices {
        jsonMap["javaGenericServices"] = javaGenericServices
      }
      if hasPyGenericServices {
        jsonMap["pyGenericServices"] = pyGenericServices
      }
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if hasCcEnableArenas {
        jsonMap["ccEnableArenas"] = ccEnableArenas
      }
      if hasObjcClassPrefix {
        jsonMap["objcClassPrefix"] = objcClassPrefix
      }
      if hasCsharpNamespace {
        jsonMap["csharpNamespace"] = csharpNamespace
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,Any>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption.append(ecodedMessageUninterpretedOption)
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.FileOptions {
      return try Google.Protobuf.FileOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.FileOptions {
      return try Google.Protobuf.FileOptions.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasJavaPackage {
        output += "\(indent) javaPackage: \(javaPackage) \n"
      }
      if hasJavaOuterClassname {
        output += "\(indent) javaOuterClassname: \(javaOuterClassname) \n"
      }
      if (hasOptimizeFor) {
        output += "\(indent) optimizeFor: \(optimizeFor.description)\n"
      }
      if hasJavaMultipleFiles {
        output += "\(indent) javaMultipleFiles: \(javaMultipleFiles) \n"
      }
      if hasGoPackage {
        output += "\(indent) goPackage: \(goPackage) \n"
      }
      if hasCcGenericServices {
        output += "\(indent) ccGenericServices: \(ccGenericServices) \n"
      }
      if hasJavaGenericServices {
        output += "\(indent) javaGenericServices: \(javaGenericServices) \n"
      }
      if hasPyGenericServices {
        output += "\(indent) pyGenericServices: \(pyGenericServices) \n"
      }
      if hasJavaGenerateEqualsAndHash {
        output += "\(indent) javaGenerateEqualsAndHash: \(javaGenerateEqualsAndHash) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      if hasJavaStringCheckUtf8 {
        output += "\(indent) javaStringCheckUtf8: \(javaStringCheckUtf8) \n"
      }
      if hasCcEnableArenas {
        output += "\(indent) ccEnableArenas: \(ccEnableArenas) \n"
      }
      if hasObjcClassPrefix {
        output += "\(indent) objcClassPrefix: \(objcClassPrefix) \n"
      }
      if hasCsharpNamespace {
        output += "\(indent) csharpNamespace: \(csharpNamespace) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(startInclusive:1000, endExclusive:536870912, indent:indent)
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasJavaPackage {
               hashCode = (hashCode &* 31) &+ javaPackage.hashValue
            }
            if hasJavaOuterClassname {
               hashCode = (hashCode &* 31) &+ javaOuterClassname.hashValue
            }
            if hasOptimizeFor {
               hashCode = (hashCode &* 31) &+ Int(optimizeFor.rawValue)
            }
            if hasJavaMultipleFiles {
               hashCode = (hashCode &* 31) &+ javaMultipleFiles.hashValue
            }
            if hasGoPackage {
               hashCode = (hashCode &* 31) &+ goPackage.hashValue
            }
            if hasCcGenericServices {
               hashCode = (hashCode &* 31) &+ ccGenericServices.hashValue
            }
            if hasJavaGenericServices {
               hashCode = (hashCode &* 31) &+ javaGenericServices.hashValue
            }
            if hasPyGenericServices {
               hashCode = (hashCode &* 31) &+ pyGenericServices.hashValue
            }
            if hasJavaGenerateEqualsAndHash {
               hashCode = (hashCode &* 31) &+ javaGenerateEqualsAndHash.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            if hasJavaStringCheckUtf8 {
               hashCode = (hashCode &* 31) &+ javaStringCheckUtf8.hashValue
            }
            if hasCcEnableArenas {
               hashCode = (hashCode &* 31) &+ ccEnableArenas.hashValue
            }
            if hasObjcClassPrefix {
               hashCode = (hashCode &* 31) &+ objcClassPrefix.hashValue
            }
            if hasCsharpNamespace {
               hashCode = (hashCode &* 31) &+ csharpNamespace.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:536870912))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.FileOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.FileOptions"
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.FileOptions = Google.Protobuf.FileOptions()
      public func getMessage() -> Google.Protobuf.FileOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasJavaPackage:Bool {
           get {
                return builderResult.hasJavaPackage
           }
      }
      public var javaPackage:String {
           get {
                return builderResult.javaPackage
           }
           set (value) {
               builderResult.hasJavaPackage = true
               builderResult.javaPackage = value
           }
      }
      @discardableResult
      public func setJavaPackage(_ value:String) -> Google.Protobuf.FileOptions.Builder {
        self.javaPackage = value
        return self
      }
      @discardableResult
      public func clearJavaPackage() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaPackage = false
           builderResult.javaPackage = ""
           return self
      }
      public var hasJavaOuterClassname:Bool {
           get {
                return builderResult.hasJavaOuterClassname
           }
      }
      public var javaOuterClassname:String {
           get {
                return builderResult.javaOuterClassname
           }
           set (value) {
               builderResult.hasJavaOuterClassname = true
               builderResult.javaOuterClassname = value
           }
      }
      @discardableResult
      public func setJavaOuterClassname(_ value:String) -> Google.Protobuf.FileOptions.Builder {
        self.javaOuterClassname = value
        return self
      }
      @discardableResult
      public func clearJavaOuterClassname() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaOuterClassname = false
           builderResult.javaOuterClassname = ""
           return self
      }
      public var hasJavaMultipleFiles:Bool {
           get {
                return builderResult.hasJavaMultipleFiles
           }
      }
      public var javaMultipleFiles:Bool {
           get {
                return builderResult.javaMultipleFiles
           }
           set (value) {
               builderResult.hasJavaMultipleFiles = true
               builderResult.javaMultipleFiles = value
           }
      }
      @discardableResult
      public func setJavaMultipleFiles(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.javaMultipleFiles = value
        return self
      }
      @discardableResult
      public func clearJavaMultipleFiles() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaMultipleFiles = false
           builderResult.javaMultipleFiles = false
           return self
      }
      public var hasJavaGenerateEqualsAndHash:Bool {
           get {
                return builderResult.hasJavaGenerateEqualsAndHash
           }
      }
      public var javaGenerateEqualsAndHash:Bool {
           get {
                return builderResult.javaGenerateEqualsAndHash
           }
           set (value) {
               builderResult.hasJavaGenerateEqualsAndHash = true
               builderResult.javaGenerateEqualsAndHash = value
           }
      }
      @discardableResult
      public func setJavaGenerateEqualsAndHash(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.javaGenerateEqualsAndHash = value
        return self
      }
      @discardableResult
      public func clearJavaGenerateEqualsAndHash() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaGenerateEqualsAndHash = false
           builderResult.javaGenerateEqualsAndHash = false
           return self
      }
      public var hasJavaStringCheckUtf8:Bool {
           get {
                return builderResult.hasJavaStringCheckUtf8
           }
      }
      public var javaStringCheckUtf8:Bool {
           get {
                return builderResult.javaStringCheckUtf8
           }
           set (value) {
               builderResult.hasJavaStringCheckUtf8 = true
               builderResult.javaStringCheckUtf8 = value
           }
      }
      @discardableResult
      public func setJavaStringCheckUtf8(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.javaStringCheckUtf8 = value
        return self
      }
      @discardableResult
      public func clearJavaStringCheckUtf8() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaStringCheckUtf8 = false
           builderResult.javaStringCheckUtf8 = false
           return self
      }
        public var hasOptimizeFor:Bool{
            get {
                return builderResult.hasOptimizeFor
            }
        }
        public var optimizeFor:Google.Protobuf.FileOptions.OptimizeMode {
            get {
                return builderResult.optimizeFor
            }
            set (value) {
                builderResult.hasOptimizeFor = true
                builderResult.optimizeFor = value
            }
        }
      @discardableResult
        public func setOptimizeFor(_ value:Google.Protobuf.FileOptions.OptimizeMode) -> Google.Protobuf.FileOptions.Builder {
          self.optimizeFor = value
          return self
        }
      @discardableResult
        public func clearOptimizeFor() -> Google.Protobuf.FileOptions.Builder {
           builderResult.hasOptimizeFor = false
           builderResult.optimizeFor = .speed
           return self
        }
      public var hasGoPackage:Bool {
           get {
                return builderResult.hasGoPackage
           }
      }
      public var goPackage:String {
           get {
                return builderResult.goPackage
           }
           set (value) {
               builderResult.hasGoPackage = true
               builderResult.goPackage = value
           }
      }
      @discardableResult
      public func setGoPackage(_ value:String) -> Google.Protobuf.FileOptions.Builder {
        self.goPackage = value
        return self
      }
      @discardableResult
      public func clearGoPackage() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasGoPackage = false
           builderResult.goPackage = ""
           return self
      }
      public var hasCcGenericServices:Bool {
           get {
                return builderResult.hasCcGenericServices
           }
      }
      public var ccGenericServices:Bool {
           get {
                return builderResult.ccGenericServices
           }
           set (value) {
               builderResult.hasCcGenericServices = true
               builderResult.ccGenericServices = value
           }
      }
      @discardableResult
      public func setCcGenericServices(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.ccGenericServices = value
        return self
      }
      @discardableResult
      public func clearCcGenericServices() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasCcGenericServices = false
           builderResult.ccGenericServices = false
           return self
      }
      public var hasJavaGenericServices:Bool {
           get {
                return builderResult.hasJavaGenericServices
           }
      }
      public var javaGenericServices:Bool {
           get {
                return builderResult.javaGenericServices
           }
           set (value) {
               builderResult.hasJavaGenericServices = true
               builderResult.javaGenericServices = value
           }
      }
      @discardableResult
      public func setJavaGenericServices(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.javaGenericServices = value
        return self
      }
      @discardableResult
      public func clearJavaGenericServices() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaGenericServices = false
           builderResult.javaGenericServices = false
           return self
      }
      public var hasPyGenericServices:Bool {
           get {
                return builderResult.hasPyGenericServices
           }
      }
      public var pyGenericServices:Bool {
           get {
                return builderResult.pyGenericServices
           }
           set (value) {
               builderResult.hasPyGenericServices = true
               builderResult.pyGenericServices = value
           }
      }
      @discardableResult
      public func setPyGenericServices(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.pyGenericServices = value
        return self
      }
      @discardableResult
      public func clearPyGenericServices() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasPyGenericServices = false
           builderResult.pyGenericServices = false
           return self
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      @discardableResult
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.deprecated = value
        return self
      }
      @discardableResult
      public func clearDeprecated() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var hasCcEnableArenas:Bool {
           get {
                return builderResult.hasCcEnableArenas
           }
      }
      public var ccEnableArenas:Bool {
           get {
                return builderResult.ccEnableArenas
           }
           set (value) {
               builderResult.hasCcEnableArenas = true
               builderResult.ccEnableArenas = value
           }
      }
      @discardableResult
      public func setCcEnableArenas(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.ccEnableArenas = value
        return self
      }
      @discardableResult
      public func clearCcEnableArenas() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasCcEnableArenas = false
           builderResult.ccEnableArenas = false
           return self
      }
      public var hasObjcClassPrefix:Bool {
           get {
                return builderResult.hasObjcClassPrefix
           }
      }
      public var objcClassPrefix:String {
           get {
                return builderResult.objcClassPrefix
           }
           set (value) {
               builderResult.hasObjcClassPrefix = true
               builderResult.objcClassPrefix = value
           }
      }
      @discardableResult
      public func setObjcClassPrefix(_ value:String) -> Google.Protobuf.FileOptions.Builder {
        self.objcClassPrefix = value
        return self
      }
      @discardableResult
      public func clearObjcClassPrefix() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasObjcClassPrefix = false
           builderResult.objcClassPrefix = ""
           return self
      }
      public var hasCsharpNamespace:Bool {
           get {
                return builderResult.hasCsharpNamespace
           }
      }
      public var csharpNamespace:String {
           get {
                return builderResult.csharpNamespace
           }
           set (value) {
               builderResult.hasCsharpNamespace = true
               builderResult.csharpNamespace = value
           }
      }
      @discardableResult
      public func setCsharpNamespace(_ value:String) -> Google.Protobuf.FileOptions.Builder {
        self.csharpNamespace = value
        return self
      }
      @discardableResult
      public func clearCsharpNamespace() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasCsharpNamespace = false
           builderResult.csharpNamespace = ""
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      @discardableResult
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.FileOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      @discardableResult
      public func clearUninterpretedOption() -> Google.Protobuf.FileOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.FileOptions.Builder {
        builderResult = Google.Protobuf.FileOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.FileOptions.Builder {
        return try Google.Protobuf.FileOptions.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.FileOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.FileOptions {
        let returnMe:Google.Protobuf.FileOptions = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.FileOptions) throws -> Google.Protobuf.FileOptions.Builder {
        if other == Google.Protobuf.FileOptions() {
         return self
        }
        if other.hasJavaPackage {
             javaPackage = other.javaPackage
        }
        if other.hasJavaOuterClassname {
             javaOuterClassname = other.javaOuterClassname
        }
        if other.hasJavaMultipleFiles {
             javaMultipleFiles = other.javaMultipleFiles
        }
        if other.hasJavaGenerateEqualsAndHash {
             javaGenerateEqualsAndHash = other.javaGenerateEqualsAndHash
        }
        if other.hasJavaStringCheckUtf8 {
             javaStringCheckUtf8 = other.javaStringCheckUtf8
        }
        if other.hasOptimizeFor {
             optimizeFor = other.optimizeFor
        }
        if other.hasGoPackage {
             goPackage = other.goPackage
        }
        if other.hasCcGenericServices {
             ccGenericServices = other.ccGenericServices
        }
        if other.hasJavaGenericServices {
             javaGenericServices = other.javaGenericServices
        }
        if other.hasPyGenericServices {
             pyGenericServices = other.pyGenericServices
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if other.hasCcEnableArenas {
             ccEnableArenas = other.ccEnableArenas
        }
        if other.hasObjcClassPrefix {
             objcClassPrefix = other.objcClassPrefix
        }
        if other.hasCsharpNamespace {
             csharpNamespace = other.csharpNamespace
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other: other)
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.FileOptions.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            javaPackage = try codedInputStream.readString()

          case 66:
            javaOuterClassname = try codedInputStream.readString()

          case 72:
            let valueIntoptimizeFor = try codedInputStream.readEnum()
            if let enumsoptimizeFor = Google.Protobuf.FileOptions.OptimizeMode(rawValue:valueIntoptimizeFor){
                 optimizeFor = enumsoptimizeFor
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 9, value:Int64(valueIntoptimizeFor))
            }

          case 80:
            javaMultipleFiles = try codedInputStream.readBool()

          case 90:
            goPackage = try codedInputStream.readString()

          case 128:
            ccGenericServices = try codedInputStream.readBool()

          case 136:
            javaGenericServices = try codedInputStream.readBool()

          case 144:
            pyGenericServices = try codedInputStream.readBool()

          case 160:
            javaGenerateEqualsAndHash = try codedInputStream.readBool()

          case 184:
            deprecated = try codedInputStream.readBool()

          case 216:
            javaStringCheckUtf8 = try codedInputStream.readBool()

          case 248:
            ccEnableArenas = try codedInputStream.readBool()

          case 290:
            objcClassPrefix = try codedInputStream.readString()

          case 298:
            csharpNamespace = try codedInputStream.readString()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.FileOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.FileOptions.Builder()
        if let jsonValueJavaPackage = jsonMap["javaPackage"] as? String {
          resultDecodedBuilder.javaPackage = jsonValueJavaPackage
        }
        if let jsonValueJavaOuterClassname = jsonMap["javaOuterClassname"] as? String {
          resultDecodedBuilder.javaOuterClassname = jsonValueJavaOuterClassname
        }
        if let jsonValueJavaMultipleFiles = jsonMap["javaMultipleFiles"] as? Bool {
          resultDecodedBuilder.javaMultipleFiles = jsonValueJavaMultipleFiles
        }
        if let jsonValueJavaGenerateEqualsAndHash = jsonMap["javaGenerateEqualsAndHash"] as? Bool {
          resultDecodedBuilder.javaGenerateEqualsAndHash = jsonValueJavaGenerateEqualsAndHash
        }
        if let jsonValueJavaStringCheckUtf8 = jsonMap["javaStringCheckUtf8"] as? Bool {
          resultDecodedBuilder.javaStringCheckUtf8 = jsonValueJavaStringCheckUtf8
        }
        if let jsonValueOptimizeFor = jsonMap["optimizeFor"] as? String {
          resultDecodedBuilder.optimizeFor = try Google.Protobuf.FileOptions.OptimizeMode.fromString(str: jsonValueOptimizeFor)
        }
        if let jsonValueGoPackage = jsonMap["goPackage"] as? String {
          resultDecodedBuilder.goPackage = jsonValueGoPackage
        }
        if let jsonValueCcGenericServices = jsonMap["ccGenericServices"] as? Bool {
          resultDecodedBuilder.ccGenericServices = jsonValueCcGenericServices
        }
        if let jsonValueJavaGenericServices = jsonMap["javaGenericServices"] as? Bool {
          resultDecodedBuilder.javaGenericServices = jsonValueJavaGenericServices
        }
        if let jsonValuePyGenericServices = jsonMap["pyGenericServices"] as? Bool {
          resultDecodedBuilder.pyGenericServices = jsonValuePyGenericServices
        }
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueCcEnableArenas = jsonMap["ccEnableArenas"] as? Bool {
          resultDecodedBuilder.ccEnableArenas = jsonValueCcEnableArenas
        }
        if let jsonValueObjcClassPrefix = jsonMap["objcClassPrefix"] as? String {
          resultDecodedBuilder.objcClassPrefix = jsonValueObjcClassPrefix
        }
        if let jsonValueCsharpNamespace = jsonMap["csharpNamespace"] as? String {
          resultDecodedBuilder.csharpNamespace = jsonValueCsharpNamespace
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,Any>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsonMap:oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption.append(messageFromStringUninterpretedOption)
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.FileOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.FileOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class MessageOptions : ExtendableMessage {

    public static func == (lhs: Google.Protobuf.MessageOptions, rhs: Google.Protobuf.MessageOptions) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasMessageSetWireFormat == rhs.hasMessageSetWireFormat) && (!lhs.hasMessageSetWireFormat || lhs.messageSetWireFormat == rhs.messageSetWireFormat)
      fieldCheck = fieldCheck && (lhs.hasNoStandardDescriptorAccessor == rhs.hasNoStandardDescriptorAccessor) && (!lhs.hasNoStandardDescriptorAccessor || lhs.noStandardDescriptorAccessor == rhs.noStandardDescriptorAccessor)
      fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
      fieldCheck = fieldCheck && (lhs.hasMapEntry == rhs.hasMapEntry) && (!lhs.hasMapEntry || lhs.mapEntry == rhs.mapEntry)
      fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
      fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:536870912)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    // Set true to use the old proto1 MessageSet wire format for extensions.
    // This is provided for backwards-compatibility with the MessageSet wire
    // format.  You should not use this for any other reason:  It's less
    // efficient, has fewer features, and is more complicated.
    // The message must be defined exactly as follows:
    //   message Foo {
    //     option message_set_wire_format = true;
    //     extensions 4 to max;
    //   }
    // Note that the message cannot have any defined fields; MessageSets only
    // have extensions.
    // All extensions of your type must be singular messages; e.g. they cannot
    // be int32s, enums, or repeated messages.
    // Because this is an option, the above two restrictions are not enforced by
    // the protocol compiler.
    public fileprivate(set) var messageSetWireFormat:Bool = false
    public fileprivate(set) var hasMessageSetWireFormat:Bool = false

    // Disables the generation of the standard "descriptor()" accessor, which can
    // conflict with a field of the same name.  This is meant to make migration
    // from proto1 easier; new code should avoid fields named "descriptor".
    public fileprivate(set) var noStandardDescriptorAccessor:Bool = false
    public fileprivate(set) var hasNoStandardDescriptorAccessor:Bool = false

    // Is this message deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for the message, or it will be completely ignored; in the very least,
    // this is a formalization for deprecating messages.
    public fileprivate(set) var deprecated:Bool = false
    public fileprivate(set) var hasDeprecated:Bool = false

    // Whether the message is an automatically generated map entry type for the
    // maps field.
    // For maps fields:
    //     map<KeyType, ValueType> map_field = 1;
    // The parsed descriptor looks like:
    //     message MapFieldEntry {
    //         option map_entry = true;
    //         optional KeyType key = 1;
    //         optional ValueType value = 2;
    //     }
    //     repeated MapFieldEntry map_field = 1;
    // Implementations may choose not to generate the map_entry=true message, but
    // use a native map in the target language to hold the keys and values.
    // The reflection APIs in such implementions still need to work as
    // if the field is a repeated message field.
    // NOTE: Do not set the option in .proto files. Always use the maps syntax
    // instead. The option should only be implicitly set by the proto compiler
    // parser.
    public fileprivate(set) var mapEntry:Bool = false
    public fileprivate(set) var hasMapEntry:Bool = false

    public fileprivate(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasMessageSetWireFormat {
        try codedOutputStream.writeBool(fieldNumber: 1, value:messageSetWireFormat)
      }
      if hasNoStandardDescriptorAccessor {
        try codedOutputStream.writeBool(fieldNumber: 2, value:noStandardDescriptorAccessor)
      }
      if hasDeprecated {
        try codedOutputStream.writeBool(fieldNumber: 3, value:deprecated)
      }
      if hasMapEntry {
        try codedOutputStream.writeBool(fieldNumber: 7, value:mapEntry)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try codedOutputStream.writeMessage(fieldNumber: 999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:536870912)
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasMessageSetWireFormat {
        serialize_size += messageSetWireFormat.computeBoolSize(fieldNumber: 1)
      }
      if hasNoStandardDescriptorAccessor {
        serialize_size += noStandardDescriptorAccessor.computeBoolSize(fieldNumber: 2)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(fieldNumber: 3)
      }
      if hasMapEntry {
        serialize_size += mapEntry.computeBoolSize(fieldNumber: 7)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(fieldNumber: 999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.MessageOptions.Builder {
      return Google.Protobuf.MessageOptions.classBuilder() as! Google.Protobuf.MessageOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.MessageOptions.Builder {
      return classBuilder() as! Google.Protobuf.MessageOptions.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.MessageOptions.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.MessageOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.MessageOptions.Builder {
      return try Google.Protobuf.MessageOptions.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.MessageOptions) throws -> Google.Protobuf.MessageOptions.Builder {
      return try Google.Protobuf.MessageOptions.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasMessageSetWireFormat {
        jsonMap["messageSetWireFormat"] = messageSetWireFormat
      }
      if hasNoStandardDescriptorAccessor {
        jsonMap["noStandardDescriptorAccessor"] = noStandardDescriptorAccessor
      }
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if hasMapEntry {
        jsonMap["mapEntry"] = mapEntry
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,Any>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption.append(ecodedMessageUninterpretedOption)
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.MessageOptions {
      return try Google.Protobuf.MessageOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.MessageOptions {
      return try Google.Protobuf.MessageOptions.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasMessageSetWireFormat {
        output += "\(indent) messageSetWireFormat: \(messageSetWireFormat) \n"
      }
      if hasNoStandardDescriptorAccessor {
        output += "\(indent) noStandardDescriptorAccessor: \(noStandardDescriptorAccessor) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      if hasMapEntry {
        output += "\(indent) mapEntry: \(mapEntry) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(startInclusive:1000, endExclusive:536870912, indent:indent)
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMessageSetWireFormat {
               hashCode = (hashCode &* 31) &+ messageSetWireFormat.hashValue
            }
            if hasNoStandardDescriptorAccessor {
               hashCode = (hashCode &* 31) &+ noStandardDescriptorAccessor.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            if hasMapEntry {
               hashCode = (hashCode &* 31) &+ mapEntry.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:536870912))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.MessageOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.MessageOptions"
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.MessageOptions = Google.Protobuf.MessageOptions()
      public func getMessage() -> Google.Protobuf.MessageOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasMessageSetWireFormat:Bool {
           get {
                return builderResult.hasMessageSetWireFormat
           }
      }
      public var messageSetWireFormat:Bool {
           get {
                return builderResult.messageSetWireFormat
           }
           set (value) {
               builderResult.hasMessageSetWireFormat = true
               builderResult.messageSetWireFormat = value
           }
      }
      @discardableResult
      public func setMessageSetWireFormat(_ value:Bool) -> Google.Protobuf.MessageOptions.Builder {
        self.messageSetWireFormat = value
        return self
      }
      @discardableResult
      public func clearMessageSetWireFormat() -> Google.Protobuf.MessageOptions.Builder{
           builderResult.hasMessageSetWireFormat = false
           builderResult.messageSetWireFormat = false
           return self
      }
      public var hasNoStandardDescriptorAccessor:Bool {
           get {
                return builderResult.hasNoStandardDescriptorAccessor
           }
      }
      public var noStandardDescriptorAccessor:Bool {
           get {
                return builderResult.noStandardDescriptorAccessor
           }
           set (value) {
               builderResult.hasNoStandardDescriptorAccessor = true
               builderResult.noStandardDescriptorAccessor = value
           }
      }
      @discardableResult
      public func setNoStandardDescriptorAccessor(_ value:Bool) -> Google.Protobuf.MessageOptions.Builder {
        self.noStandardDescriptorAccessor = value
        return self
      }
      @discardableResult
      public func clearNoStandardDescriptorAccessor() -> Google.Protobuf.MessageOptions.Builder{
           builderResult.hasNoStandardDescriptorAccessor = false
           builderResult.noStandardDescriptorAccessor = false
           return self
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      @discardableResult
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.MessageOptions.Builder {
        self.deprecated = value
        return self
      }
      @discardableResult
      public func clearDeprecated() -> Google.Protobuf.MessageOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var hasMapEntry:Bool {
           get {
                return builderResult.hasMapEntry
           }
      }
      public var mapEntry:Bool {
           get {
                return builderResult.mapEntry
           }
           set (value) {
               builderResult.hasMapEntry = true
               builderResult.mapEntry = value
           }
      }
      @discardableResult
      public func setMapEntry(_ value:Bool) -> Google.Protobuf.MessageOptions.Builder {
        self.mapEntry = value
        return self
      }
      @discardableResult
      public func clearMapEntry() -> Google.Protobuf.MessageOptions.Builder{
           builderResult.hasMapEntry = false
           builderResult.mapEntry = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      @discardableResult
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.MessageOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      @discardableResult
      public func clearUninterpretedOption() -> Google.Protobuf.MessageOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.MessageOptions.Builder {
        builderResult = Google.Protobuf.MessageOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.MessageOptions.Builder {
        return try Google.Protobuf.MessageOptions.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.MessageOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.MessageOptions {
        let returnMe:Google.Protobuf.MessageOptions = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.MessageOptions) throws -> Google.Protobuf.MessageOptions.Builder {
        if other == Google.Protobuf.MessageOptions() {
         return self
        }
        if other.hasMessageSetWireFormat {
             messageSetWireFormat = other.messageSetWireFormat
        }
        if other.hasNoStandardDescriptorAccessor {
             noStandardDescriptorAccessor = other.noStandardDescriptorAccessor
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if other.hasMapEntry {
             mapEntry = other.mapEntry
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other: other)
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.MessageOptions.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MessageOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            messageSetWireFormat = try codedInputStream.readBool()

          case 16:
            noStandardDescriptorAccessor = try codedInputStream.readBool()

          case 24:
            deprecated = try codedInputStream.readBool()

          case 56:
            mapEntry = try codedInputStream.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.MessageOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.MessageOptions.Builder()
        if let jsonValueMessageSetWireFormat = jsonMap["messageSetWireFormat"] as? Bool {
          resultDecodedBuilder.messageSetWireFormat = jsonValueMessageSetWireFormat
        }
        if let jsonValueNoStandardDescriptorAccessor = jsonMap["noStandardDescriptorAccessor"] as? Bool {
          resultDecodedBuilder.noStandardDescriptorAccessor = jsonValueNoStandardDescriptorAccessor
        }
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueMapEntry = jsonMap["mapEntry"] as? Bool {
          resultDecodedBuilder.mapEntry = jsonValueMapEntry
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,Any>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsonMap:oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption.append(messageFromStringUninterpretedOption)
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.MessageOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.MessageOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class FieldOptions : ExtendableMessage {

    public static func == (lhs: Google.Protobuf.FieldOptions, rhs: Google.Protobuf.FieldOptions) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasCtype == rhs.hasCtype) && (!lhs.hasCtype || lhs.ctype == rhs.ctype)
      fieldCheck = fieldCheck && (lhs.hasPacked == rhs.hasPacked) && (!lhs.hasPacked || lhs.packed == rhs.packed)
      fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
      fieldCheck = fieldCheck && (lhs.hasLazy == rhs.hasLazy) && (!lhs.hasLazy || lhs.`lazy` == rhs.`lazy`)
      fieldCheck = fieldCheck && (lhs.hasJstype == rhs.hasJstype) && (!lhs.hasJstype || lhs.jstype == rhs.jstype)
      fieldCheck = fieldCheck && (lhs.hasWeak == rhs.hasWeak) && (!lhs.hasWeak || lhs.`weak` == rhs.`weak`)
      fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
      fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:536870912)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Ctype:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // Default mode.
        case `String` = 0
        case cord = 1
        case stringPiece = 2
        public func toString() -> String {
          switch self {
          case .`String`: return "STRING"
          case .cord: return "CORD"
          case .stringPiece: return "STRING_PIECE"
          }
        }
        public static func fromString(str:String) throws -> Google.Protobuf.FieldOptions.Ctype {
          switch str {
          case "STRING":  return .`String`
          case "CORD":  return .cord
          case "STRING_PIECE":  return .stringPiece
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .`String`: return ".`String`"
          case .cord: return ".cord"
          case .stringPiece: return ".stringPiece"
          }
        }
      }

      //Enum type declaration end 



      //Enum type declaration start 

      public enum Jstype:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // Use the default type.
        case jsNormal = 0

        // Use JavaScript strings.
        case jsString = 1

        // Use JavaScript numbers.
        case jsNumber = 2
        public func toString() -> String {
          switch self {
          case .jsNormal: return "JS_NORMAL"
          case .jsString: return "JS_STRING"
          case .jsNumber: return "JS_NUMBER"
          }
        }
        public static func fromString(str:String) throws -> Google.Protobuf.FieldOptions.Jstype {
          switch str {
          case "JS_NORMAL":  return .jsNormal
          case "JS_STRING":  return .jsString
          case "JS_NUMBER":  return .jsNumber
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .jsNormal: return ".jsNormal"
          case .jsString: return ".jsString"
          case .jsNumber: return ".jsNumber"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var ctype:Google.Protobuf.FieldOptions.Ctype = Google.Protobuf.FieldOptions.Ctype.`String`
    public fileprivate(set) var hasCtype:Bool = false
    // The packed option can be enabled for repeated primitive fields to enable
    // a more efficient representation on the wire. Rather than repeatedly
    // writing the tag and type for each element, the entire array is encoded as
    // a single length-delimited blob. In proto3, only explicit setting it to
    // false will avoid using packed encoding.
    public fileprivate(set) var packed:Bool = false
    public fileprivate(set) var hasPacked:Bool = false

    public fileprivate(set) var jstype:Google.Protobuf.FieldOptions.Jstype = Google.Protobuf.FieldOptions.Jstype.jsNormal
    public fileprivate(set) var hasJstype:Bool = false
    // Should this field be parsed lazily?  Lazy applies only to message-type
    // fields.  It means that when the outer message is initially parsed, the
    // inner message's contents will not be parsed but instead stored in encoded
    // form.  The inner message will actually be parsed when it is first accessed.
    // This is only a hint.  Implementations are free to choose whether to use
    // eager or lazy parsing regardless of the value of this option.  However,
    // setting this option true suggests that the protocol author believes that
    // using lazy parsing on this field is worth the additional bookkeeping
    // overhead typically needed to implement it.
    // This option does not affect the public interface of any generated code;
    // all method signatures remain the same.  Furthermore, thread-safety of the
    // interface is not affected by this option; const methods remain safe to
    // call from multiple threads concurrently, while non-const methods continue
    // to require exclusive access.
    // Note that implementations may choose not to check required fields within
    // a lazy sub-message.  That is, calling IsInitialized() on the outer message
    // may return true even if the inner message has missing required fields.
    // This is necessary because otherwise the inner message would have to be
    // parsed in order to perform the check, defeating the purpose of lazy
    // parsing.  An implementation which chooses not to check required fields
    // must be consistent about it.  That is, for any particular sub-message, the
    // implementation must either *always* check its required fields, or *never*
    // check its required fields, regardless of whether or not the message has
    // been parsed.
    public fileprivate(set) var `lazy`:Bool = false
    public fileprivate(set) var hasLazy:Bool = false

    // Is this field deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for accessors, or it will be completely ignored; in the very least, this
    // is a formalization for deprecating fields.
    public fileprivate(set) var deprecated:Bool = false
    public fileprivate(set) var hasDeprecated:Bool = false

    // For Google-internal migration only. Do not use.
    public fileprivate(set) var `weak`:Bool = false
    public fileprivate(set) var hasWeak:Bool = false

    public fileprivate(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasCtype {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:ctype.rawValue)
      }
      if hasPacked {
        try codedOutputStream.writeBool(fieldNumber: 2, value:packed)
      }
      if hasDeprecated {
        try codedOutputStream.writeBool(fieldNumber: 3, value:deprecated)
      }
      if hasLazy {
        try codedOutputStream.writeBool(fieldNumber: 5, value:`lazy`)
      }
      if hasJstype {
        try codedOutputStream.writeEnum(fieldNumber: 6, value:jstype.rawValue)
      }
      if hasWeak {
        try codedOutputStream.writeBool(fieldNumber: 10, value:`weak`)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try codedOutputStream.writeMessage(fieldNumber: 999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:536870912)
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasCtype) {
        serialize_size += ctype.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasPacked {
        serialize_size += packed.computeBoolSize(fieldNumber: 2)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(fieldNumber: 3)
      }
      if hasLazy {
        serialize_size += `lazy`.computeBoolSize(fieldNumber: 5)
      }
      if (hasJstype) {
        serialize_size += jstype.rawValue.computeEnumSize(fieldNumber: 6)
      }
      if hasWeak {
        serialize_size += `weak`.computeBoolSize(fieldNumber: 10)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(fieldNumber: 999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.FieldOptions.Builder {
      return Google.Protobuf.FieldOptions.classBuilder() as! Google.Protobuf.FieldOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.FieldOptions.Builder {
      return classBuilder() as! Google.Protobuf.FieldOptions.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.FieldOptions.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.FieldOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.FieldOptions.Builder {
      return try Google.Protobuf.FieldOptions.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.FieldOptions) throws -> Google.Protobuf.FieldOptions.Builder {
      return try Google.Protobuf.FieldOptions.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasCtype {
        jsonMap["ctype"] = ctype.toString()
      }
      if hasPacked {
        jsonMap["packed"] = packed
      }
      if hasJstype {
        jsonMap["jstype"] = jstype.toString()
      }
      if hasLazy {
        jsonMap["lazy"] = `lazy`
      }
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if hasWeak {
        jsonMap["weak"] = `weak`
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,Any>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption.append(ecodedMessageUninterpretedOption)
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.FieldOptions {
      return try Google.Protobuf.FieldOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.FieldOptions {
      return try Google.Protobuf.FieldOptions.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasCtype) {
        output += "\(indent) ctype: \(ctype.description)\n"
      }
      if hasPacked {
        output += "\(indent) packed: \(packed) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      if hasLazy {
        output += "\(indent) lazy: \(`lazy`) \n"
      }
      if (hasJstype) {
        output += "\(indent) jstype: \(jstype.description)\n"
      }
      if hasWeak {
        output += "\(indent) weak: \(`weak`) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(startInclusive:1000, endExclusive:536870912, indent:indent)
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCtype {
               hashCode = (hashCode &* 31) &+ Int(ctype.rawValue)
            }
            if hasPacked {
               hashCode = (hashCode &* 31) &+ packed.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            if hasLazy {
               hashCode = (hashCode &* 31) &+ `lazy`.hashValue
            }
            if hasJstype {
               hashCode = (hashCode &* 31) &+ Int(jstype.rawValue)
            }
            if hasWeak {
               hashCode = (hashCode &* 31) &+ `weak`.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:536870912))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.FieldOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.FieldOptions"
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.FieldOptions = Google.Protobuf.FieldOptions()
      public func getMessage() -> Google.Protobuf.FieldOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasCtype:Bool{
            get {
                return builderResult.hasCtype
            }
        }
        public var ctype:Google.Protobuf.FieldOptions.Ctype {
            get {
                return builderResult.ctype
            }
            set (value) {
                builderResult.hasCtype = true
                builderResult.ctype = value
            }
        }
      @discardableResult
        public func setCtype(_ value:Google.Protobuf.FieldOptions.Ctype) -> Google.Protobuf.FieldOptions.Builder {
          self.ctype = value
          return self
        }
      @discardableResult
        public func clearCtype() -> Google.Protobuf.FieldOptions.Builder {
           builderResult.hasCtype = false
           builderResult.ctype = .`String`
           return self
        }
      public var hasPacked:Bool {
           get {
                return builderResult.hasPacked
           }
      }
      public var packed:Bool {
           get {
                return builderResult.packed
           }
           set (value) {
               builderResult.hasPacked = true
               builderResult.packed = value
           }
      }
      @discardableResult
      public func setPacked(_ value:Bool) -> Google.Protobuf.FieldOptions.Builder {
        self.packed = value
        return self
      }
      @discardableResult
      public func clearPacked() -> Google.Protobuf.FieldOptions.Builder{
           builderResult.hasPacked = false
           builderResult.packed = false
           return self
      }
        public var hasJstype:Bool{
            get {
                return builderResult.hasJstype
            }
        }
        public var jstype:Google.Protobuf.FieldOptions.Jstype {
            get {
                return builderResult.jstype
            }
            set (value) {
                builderResult.hasJstype = true
                builderResult.jstype = value
            }
        }
      @discardableResult
        public func setJstype(_ value:Google.Protobuf.FieldOptions.Jstype) -> Google.Protobuf.FieldOptions.Builder {
          self.jstype = value
          return self
        }
      @discardableResult
        public func clearJstype() -> Google.Protobuf.FieldOptions.Builder {
           builderResult.hasJstype = false
           builderResult.jstype = .jsNormal
           return self
        }
      public var hasLazy:Bool {
           get {
                return builderResult.hasLazy
           }
      }
      public var `lazy`:Bool {
           get {
                return builderResult.`lazy`
           }
           set (value) {
               builderResult.hasLazy = true
               builderResult.`lazy` = value
           }
      }
      @discardableResult
      public func setLazy(_ value:Bool) -> Google.Protobuf.FieldOptions.Builder {
        self.`lazy` = value
        return self
      }
      @discardableResult
      public func clearLazy() -> Google.Protobuf.FieldOptions.Builder{
           builderResult.hasLazy = false
           builderResult.`lazy` = false
           return self
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      @discardableResult
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.FieldOptions.Builder {
        self.deprecated = value
        return self
      }
      @discardableResult
      public func clearDeprecated() -> Google.Protobuf.FieldOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var hasWeak:Bool {
           get {
                return builderResult.hasWeak
           }
      }
      public var `weak`:Bool {
           get {
                return builderResult.`weak`
           }
           set (value) {
               builderResult.hasWeak = true
               builderResult.`weak` = value
           }
      }
      @discardableResult
      public func setWeak(_ value:Bool) -> Google.Protobuf.FieldOptions.Builder {
        self.`weak` = value
        return self
      }
      @discardableResult
      public func clearWeak() -> Google.Protobuf.FieldOptions.Builder{
           builderResult.hasWeak = false
           builderResult.`weak` = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      @discardableResult
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.FieldOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      @discardableResult
      public func clearUninterpretedOption() -> Google.Protobuf.FieldOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.FieldOptions.Builder {
        builderResult = Google.Protobuf.FieldOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.FieldOptions.Builder {
        return try Google.Protobuf.FieldOptions.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.FieldOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.FieldOptions {
        let returnMe:Google.Protobuf.FieldOptions = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.FieldOptions) throws -> Google.Protobuf.FieldOptions.Builder {
        if other == Google.Protobuf.FieldOptions() {
         return self
        }
        if other.hasCtype {
             ctype = other.ctype
        }
        if other.hasPacked {
             packed = other.packed
        }
        if other.hasJstype {
             jstype = other.jstype
        }
        if other.hasLazy {
             `lazy` = other.`lazy`
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if other.hasWeak {
             `weak` = other.`weak`
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other: other)
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.FieldOptions.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntctype = try codedInputStream.readEnum()
            if let enumsctype = Google.Protobuf.FieldOptions.Ctype(rawValue:valueIntctype){
                 ctype = enumsctype
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntctype))
            }

          case 16:
            packed = try codedInputStream.readBool()

          case 24:
            deprecated = try codedInputStream.readBool()

          case 40:
            `lazy` = try codedInputStream.readBool()

          case 48:
            let valueIntjstype = try codedInputStream.readEnum()
            if let enumsjstype = Google.Protobuf.FieldOptions.Jstype(rawValue:valueIntjstype){
                 jstype = enumsjstype
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 6, value:Int64(valueIntjstype))
            }

          case 80:
            `weak` = try codedInputStream.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.FieldOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.FieldOptions.Builder()
        if let jsonValueCtype = jsonMap["ctype"] as? String {
          resultDecodedBuilder.ctype = try Google.Protobuf.FieldOptions.Ctype.fromString(str: jsonValueCtype)
        }
        if let jsonValuePacked = jsonMap["packed"] as? Bool {
          resultDecodedBuilder.packed = jsonValuePacked
        }
        if let jsonValueJstype = jsonMap["jstype"] as? String {
          resultDecodedBuilder.jstype = try Google.Protobuf.FieldOptions.Jstype.fromString(str: jsonValueJstype)
        }
        if let jsonValueLazy = jsonMap["lazy"] as? Bool {
          resultDecodedBuilder.`lazy` = jsonValueLazy
        }
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueWeak = jsonMap["weak"] as? Bool {
          resultDecodedBuilder.`weak` = jsonValueWeak
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,Any>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsonMap:oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption.append(messageFromStringUninterpretedOption)
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.FieldOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.FieldOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class OneofOptions : ExtendableMessage {

    public static func == (lhs: Google.Protobuf.OneofOptions, rhs: Google.Protobuf.OneofOptions) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
      fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:536870912)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      for oneElementUninterpretedOption in uninterpretedOption {
          try codedOutputStream.writeMessage(fieldNumber: 999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:536870912)
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(fieldNumber: 999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.OneofOptions.Builder {
      return Google.Protobuf.OneofOptions.classBuilder() as! Google.Protobuf.OneofOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.OneofOptions.Builder {
      return classBuilder() as! Google.Protobuf.OneofOptions.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.OneofOptions.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.OneofOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.OneofOptions.Builder {
      return try Google.Protobuf.OneofOptions.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.OneofOptions) throws -> Google.Protobuf.OneofOptions.Builder {
      return try Google.Protobuf.OneofOptions.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,Any>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption.append(ecodedMessageUninterpretedOption)
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.OneofOptions {
      return try Google.Protobuf.OneofOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.OneofOptions {
      return try Google.Protobuf.OneofOptions.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(startInclusive:1000, endExclusive:536870912, indent:indent)
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:536870912))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.OneofOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.OneofOptions"
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.OneofOptions = Google.Protobuf.OneofOptions()
      public func getMessage() -> Google.Protobuf.OneofOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      @discardableResult
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.OneofOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      @discardableResult
      public func clearUninterpretedOption() -> Google.Protobuf.OneofOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.OneofOptions.Builder {
        builderResult = Google.Protobuf.OneofOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.OneofOptions.Builder {
        return try Google.Protobuf.OneofOptions.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.OneofOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.OneofOptions {
        let returnMe:Google.Protobuf.OneofOptions = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.OneofOptions) throws -> Google.Protobuf.OneofOptions.Builder {
        if other == Google.Protobuf.OneofOptions() {
         return self
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other: other)
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.OneofOptions.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.OneofOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.OneofOptions.Builder()
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,Any>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsonMap:oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption.append(messageFromStringUninterpretedOption)
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.OneofOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.OneofOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class EnumOptions : ExtendableMessage {

    public static func == (lhs: Google.Protobuf.EnumOptions, rhs: Google.Protobuf.EnumOptions) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasAllowAlias == rhs.hasAllowAlias) && (!lhs.hasAllowAlias || lhs.allowAlias == rhs.allowAlias)
      fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
      fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
      fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:536870912)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    // Set this option to true to allow mapping different tag names to the same
    // value.
    public fileprivate(set) var allowAlias:Bool = false
    public fileprivate(set) var hasAllowAlias:Bool = false

    // Is this enum deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for the enum, or it will be completely ignored; in the very least, this
    // is a formalization for deprecating enums.
    public fileprivate(set) var deprecated:Bool = false
    public fileprivate(set) var hasDeprecated:Bool = false

    public fileprivate(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasAllowAlias {
        try codedOutputStream.writeBool(fieldNumber: 2, value:allowAlias)
      }
      if hasDeprecated {
        try codedOutputStream.writeBool(fieldNumber: 3, value:deprecated)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try codedOutputStream.writeMessage(fieldNumber: 999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:536870912)
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasAllowAlias {
        serialize_size += allowAlias.computeBoolSize(fieldNumber: 2)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(fieldNumber: 3)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(fieldNumber: 999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.EnumOptions.Builder {
      return Google.Protobuf.EnumOptions.classBuilder() as! Google.Protobuf.EnumOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.EnumOptions.Builder {
      return classBuilder() as! Google.Protobuf.EnumOptions.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.EnumOptions.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.EnumOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.EnumOptions.Builder {
      return try Google.Protobuf.EnumOptions.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.EnumOptions) throws -> Google.Protobuf.EnumOptions.Builder {
      return try Google.Protobuf.EnumOptions.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasAllowAlias {
        jsonMap["allowAlias"] = allowAlias
      }
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,Any>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption.append(ecodedMessageUninterpretedOption)
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.EnumOptions {
      return try Google.Protobuf.EnumOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.EnumOptions {
      return try Google.Protobuf.EnumOptions.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasAllowAlias {
        output += "\(indent) allowAlias: \(allowAlias) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(startInclusive:1000, endExclusive:536870912, indent:indent)
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasAllowAlias {
               hashCode = (hashCode &* 31) &+ allowAlias.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:536870912))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.EnumOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.EnumOptions"
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.EnumOptions = Google.Protobuf.EnumOptions()
      public func getMessage() -> Google.Protobuf.EnumOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasAllowAlias:Bool {
           get {
                return builderResult.hasAllowAlias
           }
      }
      public var allowAlias:Bool {
           get {
                return builderResult.allowAlias
           }
           set (value) {
               builderResult.hasAllowAlias = true
               builderResult.allowAlias = value
           }
      }
      @discardableResult
      public func setAllowAlias(_ value:Bool) -> Google.Protobuf.EnumOptions.Builder {
        self.allowAlias = value
        return self
      }
      @discardableResult
      public func clearAllowAlias() -> Google.Protobuf.EnumOptions.Builder{
           builderResult.hasAllowAlias = false
           builderResult.allowAlias = false
           return self
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      @discardableResult
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.EnumOptions.Builder {
        self.deprecated = value
        return self
      }
      @discardableResult
      public func clearDeprecated() -> Google.Protobuf.EnumOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      @discardableResult
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.EnumOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      @discardableResult
      public func clearUninterpretedOption() -> Google.Protobuf.EnumOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.EnumOptions.Builder {
        builderResult = Google.Protobuf.EnumOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.EnumOptions.Builder {
        return try Google.Protobuf.EnumOptions.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.EnumOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.EnumOptions {
        let returnMe:Google.Protobuf.EnumOptions = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.EnumOptions) throws -> Google.Protobuf.EnumOptions.Builder {
        if other == Google.Protobuf.EnumOptions() {
         return self
        }
        if other.hasAllowAlias {
             allowAlias = other.allowAlias
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other: other)
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.EnumOptions.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 16:
            allowAlias = try codedInputStream.readBool()

          case 24:
            deprecated = try codedInputStream.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.EnumOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.EnumOptions.Builder()
        if let jsonValueAllowAlias = jsonMap["allowAlias"] as? Bool {
          resultDecodedBuilder.allowAlias = jsonValueAllowAlias
        }
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,Any>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsonMap:oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption.append(messageFromStringUninterpretedOption)
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.EnumOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.EnumOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class EnumValueOptions : ExtendableMessage {

    public static func == (lhs: Google.Protobuf.EnumValueOptions, rhs: Google.Protobuf.EnumValueOptions) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
      fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
      fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:536870912)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    // Is this enum value deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for the enum value, or it will be completely ignored; in the very least,
    // this is a formalization for deprecating enum values.
    public fileprivate(set) var deprecated:Bool = false
    public fileprivate(set) var hasDeprecated:Bool = false

    public fileprivate(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasDeprecated {
        try codedOutputStream.writeBool(fieldNumber: 1, value:deprecated)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try codedOutputStream.writeMessage(fieldNumber: 999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:536870912)
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(fieldNumber: 1)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(fieldNumber: 999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.EnumValueOptions.Builder {
      return Google.Protobuf.EnumValueOptions.classBuilder() as! Google.Protobuf.EnumValueOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.EnumValueOptions.Builder {
      return classBuilder() as! Google.Protobuf.EnumValueOptions.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.EnumValueOptions.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.EnumValueOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.EnumValueOptions.Builder {
      return try Google.Protobuf.EnumValueOptions.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.EnumValueOptions) throws -> Google.Protobuf.EnumValueOptions.Builder {
      return try Google.Protobuf.EnumValueOptions.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,Any>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption.append(ecodedMessageUninterpretedOption)
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.EnumValueOptions {
      return try Google.Protobuf.EnumValueOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.EnumValueOptions {
      return try Google.Protobuf.EnumValueOptions.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(startInclusive:1000, endExclusive:536870912, indent:indent)
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:536870912))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.EnumValueOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.EnumValueOptions"
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.EnumValueOptions = Google.Protobuf.EnumValueOptions()
      public func getMessage() -> Google.Protobuf.EnumValueOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      @discardableResult
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.EnumValueOptions.Builder {
        self.deprecated = value
        return self
      }
      @discardableResult
      public func clearDeprecated() -> Google.Protobuf.EnumValueOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      @discardableResult
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.EnumValueOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      @discardableResult
      public func clearUninterpretedOption() -> Google.Protobuf.EnumValueOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.EnumValueOptions.Builder {
        builderResult = Google.Protobuf.EnumValueOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.EnumValueOptions.Builder {
        return try Google.Protobuf.EnumValueOptions.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.EnumValueOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.EnumValueOptions {
        let returnMe:Google.Protobuf.EnumValueOptions = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.EnumValueOptions) throws -> Google.Protobuf.EnumValueOptions.Builder {
        if other == Google.Protobuf.EnumValueOptions() {
         return self
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other: other)
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.EnumValueOptions.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            deprecated = try codedInputStream.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.EnumValueOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.EnumValueOptions.Builder()
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,Any>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsonMap:oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption.append(messageFromStringUninterpretedOption)
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.EnumValueOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.EnumValueOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class ServiceOptions : ExtendableMessage {

    public static func == (lhs: Google.Protobuf.ServiceOptions, rhs: Google.Protobuf.ServiceOptions) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
      fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
      fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:536870912)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    // Is this service deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for the service, or it will be completely ignored; in the very least,
    // this is a formalization for deprecating services.
    public fileprivate(set) var deprecated:Bool = false
    public fileprivate(set) var hasDeprecated:Bool = false

    public fileprivate(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasDeprecated {
        try codedOutputStream.writeBool(fieldNumber: 33, value:deprecated)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try codedOutputStream.writeMessage(fieldNumber: 999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:536870912)
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(fieldNumber: 33)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(fieldNumber: 999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.ServiceOptions.Builder {
      return Google.Protobuf.ServiceOptions.classBuilder() as! Google.Protobuf.ServiceOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.ServiceOptions.Builder {
      return classBuilder() as! Google.Protobuf.ServiceOptions.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.ServiceOptions.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.ServiceOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.ServiceOptions.Builder {
      return try Google.Protobuf.ServiceOptions.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.ServiceOptions) throws -> Google.Protobuf.ServiceOptions.Builder {
      return try Google.Protobuf.ServiceOptions.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,Any>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption.append(ecodedMessageUninterpretedOption)
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.ServiceOptions {
      return try Google.Protobuf.ServiceOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.ServiceOptions {
      return try Google.Protobuf.ServiceOptions.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(startInclusive:1000, endExclusive:536870912, indent:indent)
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:536870912))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.ServiceOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.ServiceOptions"
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.ServiceOptions = Google.Protobuf.ServiceOptions()
      public func getMessage() -> Google.Protobuf.ServiceOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      @discardableResult
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.ServiceOptions.Builder {
        self.deprecated = value
        return self
      }
      @discardableResult
      public func clearDeprecated() -> Google.Protobuf.ServiceOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      @discardableResult
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.ServiceOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      @discardableResult
      public func clearUninterpretedOption() -> Google.Protobuf.ServiceOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.ServiceOptions.Builder {
        builderResult = Google.Protobuf.ServiceOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.ServiceOptions.Builder {
        return try Google.Protobuf.ServiceOptions.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.ServiceOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.ServiceOptions {
        let returnMe:Google.Protobuf.ServiceOptions = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.ServiceOptions) throws -> Google.Protobuf.ServiceOptions.Builder {
        if other == Google.Protobuf.ServiceOptions() {
         return self
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other: other)
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.ServiceOptions.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 264:
            deprecated = try codedInputStream.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.ServiceOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.ServiceOptions.Builder()
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,Any>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsonMap:oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption.append(messageFromStringUninterpretedOption)
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.ServiceOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.ServiceOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class MethodOptions : ExtendableMessage {

    public static func == (lhs: Google.Protobuf.MethodOptions, rhs: Google.Protobuf.MethodOptions) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
      fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
      fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:536870912)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    // Is this method deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for the method, or it will be completely ignored; in the very least,
    // this is a formalization for deprecating methods.
    public fileprivate(set) var deprecated:Bool = false
    public fileprivate(set) var hasDeprecated:Bool = false

    public fileprivate(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasDeprecated {
        try codedOutputStream.writeBool(fieldNumber: 33, value:deprecated)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try codedOutputStream.writeMessage(fieldNumber: 999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:536870912)
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(fieldNumber: 33)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(fieldNumber: 999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.MethodOptions.Builder {
      return Google.Protobuf.MethodOptions.classBuilder() as! Google.Protobuf.MethodOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.MethodOptions.Builder {
      return classBuilder() as! Google.Protobuf.MethodOptions.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.MethodOptions.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.MethodOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.MethodOptions.Builder {
      return try Google.Protobuf.MethodOptions.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.MethodOptions) throws -> Google.Protobuf.MethodOptions.Builder {
      return try Google.Protobuf.MethodOptions.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,Any>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption.append(ecodedMessageUninterpretedOption)
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.MethodOptions {
      return try Google.Protobuf.MethodOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.MethodOptions {
      return try Google.Protobuf.MethodOptions.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(startInclusive:1000, endExclusive:536870912, indent:indent)
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:536870912))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.MethodOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.MethodOptions"
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.MethodOptions = Google.Protobuf.MethodOptions()
      public func getMessage() -> Google.Protobuf.MethodOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      @discardableResult
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.MethodOptions.Builder {
        self.deprecated = value
        return self
      }
      @discardableResult
      public func clearDeprecated() -> Google.Protobuf.MethodOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      @discardableResult
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.MethodOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      @discardableResult
      public func clearUninterpretedOption() -> Google.Protobuf.MethodOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.MethodOptions.Builder {
        builderResult = Google.Protobuf.MethodOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.MethodOptions.Builder {
        return try Google.Protobuf.MethodOptions.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.MethodOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.MethodOptions {
        let returnMe:Google.Protobuf.MethodOptions = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.MethodOptions) throws -> Google.Protobuf.MethodOptions.Builder {
        if other == Google.Protobuf.MethodOptions() {
         return self
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other: other)
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.MethodOptions.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 264:
            deprecated = try codedInputStream.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.MethodOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.MethodOptions.Builder()
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,Any>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsonMap:oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption.append(messageFromStringUninterpretedOption)
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.MethodOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.MethodOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // A message representing a option the parser does not recognize. This only
  // appears in options protos created by the compiler::Parser class.
  // DescriptorPool resolves these when building Descriptor objects. Therefore,
  // options protos in descriptor objects (e.g. returned by Descriptor::options(),
  // or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
  // in them.
  final public class UninterpretedOption : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.UninterpretedOption, rhs: Google.Protobuf.UninterpretedOption) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.name == rhs.name)
      fieldCheck = fieldCheck && (lhs.hasIdentifierValue == rhs.hasIdentifierValue) && (!lhs.hasIdentifierValue || lhs.identifierValue == rhs.identifierValue)
      fieldCheck = fieldCheck && (lhs.hasPositiveIntValue == rhs.hasPositiveIntValue) && (!lhs.hasPositiveIntValue || lhs.positiveIntValue == rhs.positiveIntValue)
      fieldCheck = fieldCheck && (lhs.hasNegativeIntValue == rhs.hasNegativeIntValue) && (!lhs.hasNegativeIntValue || lhs.negativeIntValue == rhs.negativeIntValue)
      fieldCheck = fieldCheck && (lhs.hasDoubleValue == rhs.hasDoubleValue) && (!lhs.hasDoubleValue || lhs.doubleValue == rhs.doubleValue)
      fieldCheck = fieldCheck && (lhs.hasStringValue == rhs.hasStringValue) && (!lhs.hasStringValue || lhs.stringValue == rhs.stringValue)
      fieldCheck = fieldCheck && (lhs.hasAggregateValue == rhs.hasAggregateValue) && (!lhs.hasAggregateValue || lhs.aggregateValue == rhs.aggregateValue)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



    //Nested type declaration start

      // The name of the uninterpreted option.  Each string represents a segment in
      // a dot-separated name.  is_extension is true iff a segment represents an
      // extension (denoted with parentheses in options specs in .proto files).
      // E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
      // "foo.(bar.baz).qux".
      final public class NamePart : GeneratedMessage {

        public static func == (lhs: Google.Protobuf.UninterpretedOption.NamePart, rhs: Google.Protobuf.UninterpretedOption.NamePart) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasNamePart == rhs.hasNamePart) && (!lhs.hasNamePart || lhs.namePart == rhs.namePart)
          fieldCheck = fieldCheck && (lhs.hasIsExtension == rhs.hasIsExtension) && (!lhs.hasIsExtension || lhs.isExtension == rhs.isExtension)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        public fileprivate(set) var namePart:String = ""
        public fileprivate(set) var hasNamePart:Bool = false

        public fileprivate(set) var isExtension:Bool = false
        public fileprivate(set) var hasIsExtension:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
          if !hasNamePart {
            return false
          }
          if !hasIsExtension {
            return false
          }
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasNamePart {
            try codedOutputStream.writeString(fieldNumber: 1, value:namePart)
          }
          if hasIsExtension {
            try codedOutputStream.writeBool(fieldNumber: 2, value:isExtension)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasNamePart {
            serialize_size += namePart.computeStringSize(fieldNumber: 1)
          }
          if hasIsExtension {
            serialize_size += isExtension.computeBoolSize(fieldNumber: 2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
          return Google.Protobuf.UninterpretedOption.NamePart.classBuilder() as! Google.Protobuf.UninterpretedOption.NamePart.Builder
        }
        public func getBuilder() -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
          return classBuilder() as! Google.Protobuf.UninterpretedOption.NamePart.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Google.Protobuf.UninterpretedOption.NamePart.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Google.Protobuf.UninterpretedOption.NamePart.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
          return try Google.Protobuf.UninterpretedOption.NamePart.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.UninterpretedOption.NamePart) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasNamePart {
            jsonMap["namePart"] = namePart
          }
          if hasIsExtension {
            jsonMap["isExtension"] = isExtension
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.UninterpretedOption.NamePart {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Google.Protobuf.UninterpretedOption.NamePart {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasNamePart {
            output += "\(indent) namePart: \(namePart) \n"
          }
          if hasIsExtension {
            output += "\(indent) isExtension: \(isExtension) \n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNamePart {
                   hashCode = (hashCode &* 31) &+ namePart.hashValue
                }
                if hasIsExtension {
                   hashCode = (hashCode &* 31) &+ isExtension.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.UninterpretedOption.NamePart"
        }
        override public func className() -> String {
            return "Google.Protobuf.UninterpretedOption.NamePart"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:Google.Protobuf.UninterpretedOption.NamePart = Google.Protobuf.UninterpretedOption.NamePart()
          public func getMessage() -> Google.Protobuf.UninterpretedOption.NamePart {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasNamePart:Bool {
               get {
                    return builderResult.hasNamePart
               }
          }
          public var namePart:String {
               get {
                    return builderResult.namePart
               }
               set (value) {
                   builderResult.hasNamePart = true
                   builderResult.namePart = value
               }
          }
          @discardableResult
          public func setNamePart(_ value:String) -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            self.namePart = value
            return self
          }
          @discardableResult
          public func clearNamePart() -> Google.Protobuf.UninterpretedOption.NamePart.Builder{
               builderResult.hasNamePart = false
               builderResult.namePart = ""
               return self
          }
          public var hasIsExtension:Bool {
               get {
                    return builderResult.hasIsExtension
               }
          }
          public var isExtension:Bool {
               get {
                    return builderResult.isExtension
               }
               set (value) {
                   builderResult.hasIsExtension = true
                   builderResult.isExtension = value
               }
          }
          @discardableResult
          public func setIsExtension(_ value:Bool) -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            self.isExtension = value
            return self
          }
          @discardableResult
          public func clearIsExtension() -> Google.Protobuf.UninterpretedOption.NamePart.Builder{
               builderResult.hasIsExtension = false
               builderResult.isExtension = false
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            builderResult = Google.Protobuf.UninterpretedOption.NamePart()
            return self
          }
          override public func clone() throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            return try Google.Protobuf.UninterpretedOption.NamePart.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> Google.Protobuf.UninterpretedOption.NamePart {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Google.Protobuf.UninterpretedOption.NamePart {
            let returnMe:Google.Protobuf.UninterpretedOption.NamePart = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:Google.Protobuf.UninterpretedOption.NamePart) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            if other == Google.Protobuf.UninterpretedOption.NamePart() {
             return self
            }
            if other.hasNamePart {
                 namePart = other.namePart
            }
            if other.hasIsExtension {
                 isExtension = other.isExtension
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                namePart = try codedInputStream.readString()

              case 16:
                isExtension = try codedInputStream.readBool()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            let resultDecodedBuilder = Google.Protobuf.UninterpretedOption.NamePart.Builder()
            if let jsonValueNamePart = jsonMap["namePart"] as? String {
              resultDecodedBuilder.namePart = jsonValueNamePart
            }
            if let jsonValueIsExtension = jsonMap["isExtension"] as? Bool {
              resultDecodedBuilder.isExtension = jsonValueIsExtension
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Google.Protobuf.UninterpretedOption.NamePart.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end

    public fileprivate(set) var name:Array<Google.Protobuf.UninterpretedOption.NamePart>  = Array<Google.Protobuf.UninterpretedOption.NamePart>()
    // The value of the uninterpreted option, in whatever type the tokenizer
    // identified it as during parsing. Exactly one of these should be set.
    public fileprivate(set) var identifierValue:String = ""
    public fileprivate(set) var hasIdentifierValue:Bool = false

    public fileprivate(set) var positiveIntValue:UInt64 = UInt64(0)
    public fileprivate(set) var hasPositiveIntValue:Bool = false

    public fileprivate(set) var negativeIntValue:Int64 = Int64(0)
    public fileprivate(set) var hasNegativeIntValue:Bool = false

    public fileprivate(set) var doubleValue:Double = Double(0)
    public fileprivate(set) var hasDoubleValue:Bool = false

    public fileprivate(set) var stringValue:Data = Data()
    public fileprivate(set) var hasStringValue:Bool = false

    public fileprivate(set) var aggregateValue:String = ""
    public fileprivate(set) var hasAggregateValue:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitName:Bool = true
      for oneElementName in name {
        if !oneElementName.isInitialized() {
          isInitName = false
          break 
        }
      }
      if !isInitName {
        return isInitName
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      for oneElementName in name {
          try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementName)
      }
      if hasIdentifierValue {
        try codedOutputStream.writeString(fieldNumber: 3, value:identifierValue)
      }
      if hasPositiveIntValue {
        try codedOutputStream.writeUInt64(fieldNumber: 4, value:positiveIntValue)
      }
      if hasNegativeIntValue {
        try codedOutputStream.writeInt64(fieldNumber: 5, value:negativeIntValue)
      }
      if hasDoubleValue {
        try codedOutputStream.writeDouble(fieldNumber: 6, value:doubleValue)
      }
      if hasStringValue {
        try codedOutputStream.writeData(fieldNumber: 7, value:stringValue)
      }
      if hasAggregateValue {
        try codedOutputStream.writeString(fieldNumber: 8, value:aggregateValue)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementName in name {
          serialize_size += oneElementName.computeMessageSize(fieldNumber: 2)
      }
      if hasIdentifierValue {
        serialize_size += identifierValue.computeStringSize(fieldNumber: 3)
      }
      if hasPositiveIntValue {
        serialize_size += positiveIntValue.computeUInt64Size(fieldNumber: 4)
      }
      if hasNegativeIntValue {
        serialize_size += negativeIntValue.computeInt64Size(fieldNumber: 5)
      }
      if hasDoubleValue {
        serialize_size += doubleValue.computeDoubleSize(fieldNumber: 6)
      }
      if hasStringValue {
        serialize_size += stringValue.computeDataSize(fieldNumber: 7)
      }
      if hasAggregateValue {
        serialize_size += aggregateValue.computeStringSize(fieldNumber: 8)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.UninterpretedOption.Builder {
      return Google.Protobuf.UninterpretedOption.classBuilder() as! Google.Protobuf.UninterpretedOption.Builder
    }
    public func getBuilder() -> Google.Protobuf.UninterpretedOption.Builder {
      return classBuilder() as! Google.Protobuf.UninterpretedOption.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.UninterpretedOption.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.UninterpretedOption.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.UninterpretedOption.Builder {
      return try Google.Protobuf.UninterpretedOption.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.UninterpretedOption) throws -> Google.Protobuf.UninterpretedOption.Builder {
      return try Google.Protobuf.UninterpretedOption.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !name.isEmpty {
        var jsonArrayName:Array<Dictionary<String,Any>> = []
          for oneValueName in name {
            let ecodedMessageName = try oneValueName.encode()
            jsonArrayName.append(ecodedMessageName)
          }
        jsonMap["name"] = jsonArrayName
      }
      if hasIdentifierValue {
        jsonMap["identifierValue"] = identifierValue
      }
      if hasPositiveIntValue {
        jsonMap["positiveIntValue"] = "\(positiveIntValue)"
      }
      if hasNegativeIntValue {
        jsonMap["negativeIntValue"] = "\(negativeIntValue)"
      }
      if hasDoubleValue {
        jsonMap["doubleValue"] = Double(doubleValue)
      }
      if hasStringValue {
        jsonMap["stringValue"] = stringValue.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
      }
      if hasAggregateValue {
        jsonMap["aggregateValue"] = aggregateValue
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.UninterpretedOption {
      return try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.UninterpretedOption {
      return try Google.Protobuf.UninterpretedOption.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var nameElementIndex:Int = 0
      for oneElementName in name {
          output += "\(indent) name[\(nameElementIndex)] {\n"
          output += try oneElementName.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          nameElementIndex += 1
      }
      if hasIdentifierValue {
        output += "\(indent) identifierValue: \(identifierValue) \n"
      }
      if hasPositiveIntValue {
        output += "\(indent) positiveIntValue: \(positiveIntValue) \n"
      }
      if hasNegativeIntValue {
        output += "\(indent) negativeIntValue: \(negativeIntValue) \n"
      }
      if hasDoubleValue {
        output += "\(indent) doubleValue: \(doubleValue) \n"
      }
      if hasStringValue {
        output += "\(indent) stringValue: \(stringValue) \n"
      }
      if hasAggregateValue {
        output += "\(indent) aggregateValue: \(aggregateValue) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementName in name {
                hashCode = (hashCode &* 31) &+ oneElementName.hashValue
            }
            if hasIdentifierValue {
               hashCode = (hashCode &* 31) &+ identifierValue.hashValue
            }
            if hasPositiveIntValue {
               hashCode = (hashCode &* 31) &+ positiveIntValue.hashValue
            }
            if hasNegativeIntValue {
               hashCode = (hashCode &* 31) &+ negativeIntValue.hashValue
            }
            if hasDoubleValue {
               hashCode = (hashCode &* 31) &+ doubleValue.hashValue
            }
            if hasStringValue {
               hashCode = (hashCode &* 31) &+ stringValue.hashValue
            }
            if hasAggregateValue {
               hashCode = (hashCode &* 31) &+ aggregateValue.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.UninterpretedOption"
    }
    override public func className() -> String {
        return "Google.Protobuf.UninterpretedOption"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.UninterpretedOption = Google.Protobuf.UninterpretedOption()
      public func getMessage() -> Google.Protobuf.UninterpretedOption {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var name:Array<Google.Protobuf.UninterpretedOption.NamePart> {
           get {
               return builderResult.name
           }
           set (value) {
               builderResult.name = value
           }
      }
      @discardableResult
      public func setName(_ value:Array<Google.Protobuf.UninterpretedOption.NamePart>) -> Google.Protobuf.UninterpretedOption.Builder {
        self.name = value
        return self
      }
      @discardableResult
      public func clearName() -> Google.Protobuf.UninterpretedOption.Builder {
        builderResult.name.removeAll(keepingCapacity: false)
        return self
      }
      public var hasIdentifierValue:Bool {
           get {
                return builderResult.hasIdentifierValue
           }
      }
      public var identifierValue:String {
           get {
                return builderResult.identifierValue
           }
           set (value) {
               builderResult.hasIdentifierValue = true
               builderResult.identifierValue = value
           }
      }
      @discardableResult
      public func setIdentifierValue(_ value:String) -> Google.Protobuf.UninterpretedOption.Builder {
        self.identifierValue = value
        return self
      }
      @discardableResult
      public func clearIdentifierValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasIdentifierValue = false
           builderResult.identifierValue = ""
           return self
      }
      public var hasPositiveIntValue:Bool {
           get {
                return builderResult.hasPositiveIntValue
           }
      }
      public var positiveIntValue:UInt64 {
           get {
                return builderResult.positiveIntValue
           }
           set (value) {
               builderResult.hasPositiveIntValue = true
               builderResult.positiveIntValue = value
           }
      }
      @discardableResult
      public func setPositiveIntValue(_ value:UInt64) -> Google.Protobuf.UninterpretedOption.Builder {
        self.positiveIntValue = value
        return self
      }
      @discardableResult
      public func clearPositiveIntValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasPositiveIntValue = false
           builderResult.positiveIntValue = UInt64(0)
           return self
      }
      public var hasNegativeIntValue:Bool {
           get {
                return builderResult.hasNegativeIntValue
           }
      }
      public var negativeIntValue:Int64 {
           get {
                return builderResult.negativeIntValue
           }
           set (value) {
               builderResult.hasNegativeIntValue = true
               builderResult.negativeIntValue = value
           }
      }
      @discardableResult
      public func setNegativeIntValue(_ value:Int64) -> Google.Protobuf.UninterpretedOption.Builder {
        self.negativeIntValue = value
        return self
      }
      @discardableResult
      public func clearNegativeIntValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasNegativeIntValue = false
           builderResult.negativeIntValue = Int64(0)
           return self
      }
      public var hasDoubleValue:Bool {
           get {
                return builderResult.hasDoubleValue
           }
      }
      public var doubleValue:Double {
           get {
                return builderResult.doubleValue
           }
           set (value) {
               builderResult.hasDoubleValue = true
               builderResult.doubleValue = value
           }
      }
      @discardableResult
      public func setDoubleValue(_ value:Double) -> Google.Protobuf.UninterpretedOption.Builder {
        self.doubleValue = value
        return self
      }
      @discardableResult
      public func clearDoubleValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasDoubleValue = false
           builderResult.doubleValue = Double(0)
           return self
      }
      public var hasStringValue:Bool {
           get {
                return builderResult.hasStringValue
           }
      }
      public var stringValue:Data {
           get {
                return builderResult.stringValue
           }
           set (value) {
               builderResult.hasStringValue = true
               builderResult.stringValue = value
           }
      }
      @discardableResult
      public func setStringValue(_ value:Data) -> Google.Protobuf.UninterpretedOption.Builder {
        self.stringValue = value
        return self
      }
      @discardableResult
      public func clearStringValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasStringValue = false
           builderResult.stringValue = Data()
           return self
      }
      public var hasAggregateValue:Bool {
           get {
                return builderResult.hasAggregateValue
           }
      }
      public var aggregateValue:String {
           get {
                return builderResult.aggregateValue
           }
           set (value) {
               builderResult.hasAggregateValue = true
               builderResult.aggregateValue = value
           }
      }
      @discardableResult
      public func setAggregateValue(_ value:String) -> Google.Protobuf.UninterpretedOption.Builder {
        self.aggregateValue = value
        return self
      }
      @discardableResult
      public func clearAggregateValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasAggregateValue = false
           builderResult.aggregateValue = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.UninterpretedOption.Builder {
        builderResult = Google.Protobuf.UninterpretedOption()
        return self
      }
      override public func clone() throws -> Google.Protobuf.UninterpretedOption.Builder {
        return try Google.Protobuf.UninterpretedOption.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.UninterpretedOption {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.UninterpretedOption {
        let returnMe:Google.Protobuf.UninterpretedOption = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.UninterpretedOption) throws -> Google.Protobuf.UninterpretedOption.Builder {
        if other == Google.Protobuf.UninterpretedOption() {
         return self
        }
        if !other.name.isEmpty  {
           builderResult.name += other.name
        }
        if other.hasIdentifierValue {
             identifierValue = other.identifierValue
        }
        if other.hasPositiveIntValue {
             positiveIntValue = other.positiveIntValue
        }
        if other.hasNegativeIntValue {
             negativeIntValue = other.negativeIntValue
        }
        if other.hasDoubleValue {
             doubleValue = other.doubleValue
        }
        if other.hasStringValue {
             stringValue = other.stringValue
        }
        if other.hasAggregateValue {
             aggregateValue = other.aggregateValue
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.UninterpretedOption.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 18:
            let subBuilder = Google.Protobuf.UninterpretedOption.NamePart.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            name.append(subBuilder.buildPartial())

          case 26:
            identifierValue = try codedInputStream.readString()

          case 32:
            positiveIntValue = try codedInputStream.readUInt64()

          case 40:
            negativeIntValue = try codedInputStream.readInt64()

          case 49:
            doubleValue = try codedInputStream.readDouble()

          case 58:
            stringValue = try codedInputStream.readData()

          case 66:
            aggregateValue = try codedInputStream.readString()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.UninterpretedOption.Builder {
        let resultDecodedBuilder = Google.Protobuf.UninterpretedOption.Builder()
        if let jsonValueName = jsonMap["name"] as? Array<Dictionary<String,Any>> {
          var jsonArrayName:Array<Google.Protobuf.UninterpretedOption.NamePart> = []
          for oneValueName in jsonValueName {
            let messageFromStringName = try Google.Protobuf.UninterpretedOption.NamePart.Builder.decodeToBuilder(jsonMap:oneValueName).build()

            jsonArrayName.append(messageFromStringName)
          }
          resultDecodedBuilder.name = jsonArrayName
        }
        if let jsonValueIdentifierValue = jsonMap["identifierValue"] as? String {
          resultDecodedBuilder.identifierValue = jsonValueIdentifierValue
        }
        if let jsonValuePositiveIntValue = jsonMap["positiveIntValue"] as? String {
          resultDecodedBuilder.positiveIntValue = UInt64(jsonValuePositiveIntValue)!
        }
        if let jsonValueNegativeIntValue = jsonMap["negativeIntValue"] as? String {
          resultDecodedBuilder.negativeIntValue = Int64(jsonValueNegativeIntValue)!
        }
        if let jsonValueDoubleValue = jsonMap["doubleValue"] as? Double {
          resultDecodedBuilder.doubleValue = Double(jsonValueDoubleValue)
        }
        if let jsonValueStringValue = jsonMap["stringValue"] as? String {
          resultDecodedBuilder.stringValue = Data(base64Encoded:jsonValueStringValue, options: Data.Base64DecodingOptions(rawValue:0))!
        }
        if let jsonValueAggregateValue = jsonMap["aggregateValue"] as? String {
          resultDecodedBuilder.aggregateValue = jsonValueAggregateValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.UninterpretedOption.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // Encapsulates information about the original source file from which a
  // FileDescriptorProto was generated.
  final public class SourceCodeInfo : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.SourceCodeInfo, rhs: Google.Protobuf.SourceCodeInfo) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.location == rhs.location)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



    //Nested type declaration start

      final public class Location : GeneratedMessage {

        public static func == (lhs: Google.Protobuf.SourceCodeInfo.Location, rhs: Google.Protobuf.SourceCodeInfo.Location) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.path == rhs.path)
          fieldCheck = fieldCheck && (lhs.span == rhs.span)
          fieldCheck = fieldCheck && (lhs.hasLeadingComments == rhs.hasLeadingComments) && (!lhs.hasLeadingComments || lhs.leadingComments == rhs.leadingComments)
          fieldCheck = fieldCheck && (lhs.hasTrailingComments == rhs.hasTrailingComments) && (!lhs.hasTrailingComments || lhs.trailingComments == rhs.trailingComments)
          fieldCheck = fieldCheck && (lhs.leadingDetachedComments == rhs.leadingDetachedComments)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        // Identifies which part of the FileDescriptorProto was defined at this
        // location.
        // Each element is a field number or an index.  They form a path from
        // the root FileDescriptorProto to the place where the definition.  For
        // example, this path:
        //   [ 4, 3, 2, 7, 1 ]
        // refers to:
        //   file.message_type(3)  // 4, 3
        //       .field(7)         // 2, 7
        //       .name()           // 1
        // This is because FileDescriptorProto.message_type has field number 4:
        //   repeated DescriptorProto message_type = 4;
        // and DescriptorProto.field has field number 2:
        //   repeated FieldDescriptorProto field = 2;
        // and FieldDescriptorProto.name has field number 1:
        //   optional string name = 1;
        // Thus, the above path gives the location of a field name.  If we removed
        // the last element:
        //   [ 4, 3, 2, 7 ]
        // this path refers to the whole field declaration (from the beginning
        // of the label to the terminating semicolon).
        public fileprivate(set) var path:Array<Int32> = Array<Int32>()
        private var pathMemoizedSerializedSize:Int32 = -1
        // Always has exactly three or four elements: start line, start column,
        // end line (optional, otherwise assumed same as start line), end column.
        // These are packed into a single field for efficiency.  Note that line
        // and column numbers are zero-based -- typically you will want to add
        // 1 to each before displaying to a user.
        public fileprivate(set) var span:Array<Int32> = Array<Int32>()
        private var spanMemoizedSerializedSize:Int32 = -1
        // If this SourceCodeInfo represents a complete declaration, these are any
        // comments appearing before and after the declaration which appear to be
        // attached to the declaration.
        // A series of line comments appearing on consecutive lines, with no other
        // tokens appearing on those lines, will be treated as a single comment.
        // leading_detached_comments will keep paragraphs of comments that appear
        // before (but not connected to) the current element. Each paragraph,
        // separated by empty lines, will be one comment element in the repeated
        // field.
        // Only the comment content is provided; comment markers (e.g. //) are
        // stripped out.  For block comments, leading whitespace and an asterisk
        // will be stripped from the beginning of each line other than the first.
        // Newlines are included in the output.
        // Examples:
        //   optional int32 foo = 1;  // Comment attached to foo.
        //   // Comment attached to bar.
        //   optional int32 bar = 2;
        //   optional string baz = 3;
        //   // Comment attached to baz.
        //   // Another line attached to baz.
        //   // Comment attached to qux.
        //   //
        //   // Another line attached to qux.
        //   optional double qux = 4;
        //   // Detached comment for corge. This is not leading or trailing comments
        //   // to qux or corge because there are blank lines separating it from
        //   // both.
        //   // Detached comment for corge paragraph 2.
        //   optional string corge = 5;
        //   /* Block comment attached
        //    * to corge.  Leading asterisks
        //    * will be removed. */
        //   /* Block comment attached to
        //    * grault. */
        //   optional int32 grault = 6;
        //   // ignored detached comments.
        public fileprivate(set) var leadingComments:String = ""
        public fileprivate(set) var hasLeadingComments:Bool = false

        public fileprivate(set) var trailingComments:String = ""
        public fileprivate(set) var hasTrailingComments:Bool = false

        public fileprivate(set) var leadingDetachedComments:Array<String> = Array<String>()
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if !path.isEmpty {
            try codedOutputStream.writeRawVarint32(value: 10)
            try codedOutputStream.writeRawVarint32(value: pathMemoizedSerializedSize)
            for oneValuepath in path {
              try codedOutputStream.writeInt32NoTag(value: oneValuepath)
            }
          }
          if !span.isEmpty {
            try codedOutputStream.writeRawVarint32(value: 18)
            try codedOutputStream.writeRawVarint32(value: spanMemoizedSerializedSize)
            for oneValuespan in span {
              try codedOutputStream.writeInt32NoTag(value: oneValuespan)
            }
          }
          if hasLeadingComments {
            try codedOutputStream.writeString(fieldNumber: 3, value:leadingComments)
          }
          if hasTrailingComments {
            try codedOutputStream.writeString(fieldNumber: 4, value:trailingComments)
          }
          if !leadingDetachedComments.isEmpty {
            for oneValueleadingDetachedComments in leadingDetachedComments {
              try codedOutputStream.writeString(fieldNumber: 6, value:oneValueleadingDetachedComments)
            }
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          var dataSizePath:Int32 = 0
          for oneValuepath in path {
              dataSizePath += oneValuepath.computeInt32SizeNoTag()
          }
          serialize_size += dataSizePath
          if !path.isEmpty {
            serialize_size += 1
            serialize_size += dataSizePath.computeInt32SizeNoTag()
          }
          pathMemoizedSerializedSize = dataSizePath
          var dataSizeSpan:Int32 = 0
          for oneValuespan in span {
              dataSizeSpan += oneValuespan.computeInt32SizeNoTag()
          }
          serialize_size += dataSizeSpan
          if !span.isEmpty {
            serialize_size += 1
            serialize_size += dataSizeSpan.computeInt32SizeNoTag()
          }
          spanMemoizedSerializedSize = dataSizeSpan
          if hasLeadingComments {
            serialize_size += leadingComments.computeStringSize(fieldNumber: 3)
          }
          if hasTrailingComments {
            serialize_size += trailingComments.computeStringSize(fieldNumber: 4)
          }
          var dataSizeLeadingDetachedComments:Int32 = 0
          for oneValueleadingDetachedComments in leadingDetachedComments {
              dataSizeLeadingDetachedComments += oneValueleadingDetachedComments.computeStringSizeNoTag()
          }
          serialize_size += dataSizeLeadingDetachedComments
          serialize_size += 1 * Int32(leadingDetachedComments.count)
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
          return Google.Protobuf.SourceCodeInfo.Location.classBuilder() as! Google.Protobuf.SourceCodeInfo.Location.Builder
        }
        public func getBuilder() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
          return classBuilder() as! Google.Protobuf.SourceCodeInfo.Location.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Google.Protobuf.SourceCodeInfo.Location.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Google.Protobuf.SourceCodeInfo.Location.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
          return try Google.Protobuf.SourceCodeInfo.Location.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.SourceCodeInfo.Location) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if !path.isEmpty {
            var jsonArrayPath:Array<Int> = []
              for oneValuePath in path {
                jsonArrayPath.append(Int(oneValuePath))
              }
            jsonMap["path"] = jsonArrayPath
          }
          if !span.isEmpty {
            var jsonArraySpan:Array<Int> = []
              for oneValueSpan in span {
                jsonArraySpan.append(Int(oneValueSpan))
              }
            jsonMap["span"] = jsonArraySpan
          }
          if hasLeadingComments {
            jsonMap["leadingComments"] = leadingComments
          }
          if hasTrailingComments {
            jsonMap["trailingComments"] = trailingComments
          }
          if !leadingDetachedComments.isEmpty {
            var jsonArrayLeadingDetachedComments:Array<String> = []
              for oneValueLeadingDetachedComments in leadingDetachedComments {
                jsonArrayLeadingDetachedComments.append(oneValueLeadingDetachedComments)
              }
            jsonMap["leadingDetachedComments"] = jsonArrayLeadingDetachedComments
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.SourceCodeInfo.Location {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Google.Protobuf.SourceCodeInfo.Location {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          var pathElementIndex:Int = 0
          for oneValuePath in path  {
              output += "\(indent) path[\(pathElementIndex)]: \(oneValuePath)\n"
              pathElementIndex += 1
          }
          var spanElementIndex:Int = 0
          for oneValueSpan in span  {
              output += "\(indent) span[\(spanElementIndex)]: \(oneValueSpan)\n"
              spanElementIndex += 1
          }
          if hasLeadingComments {
            output += "\(indent) leadingComments: \(leadingComments) \n"
          }
          if hasTrailingComments {
            output += "\(indent) trailingComments: \(trailingComments) \n"
          }
          var leadingDetachedCommentsElementIndex:Int = 0
          for oneValueLeadingDetachedComments in leadingDetachedComments  {
              output += "\(indent) leadingDetachedComments[\(leadingDetachedCommentsElementIndex)]: \(oneValueLeadingDetachedComments)\n"
              leadingDetachedCommentsElementIndex += 1
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValuePath in path {
                    hashCode = (hashCode &* 31) &+ oneValuePath.hashValue
                }
                for oneValueSpan in span {
                    hashCode = (hashCode &* 31) &+ oneValueSpan.hashValue
                }
                if hasLeadingComments {
                   hashCode = (hashCode &* 31) &+ leadingComments.hashValue
                }
                if hasTrailingComments {
                   hashCode = (hashCode &* 31) &+ trailingComments.hashValue
                }
                for oneValueLeadingDetachedComments in leadingDetachedComments {
                    hashCode = (hashCode &* 31) &+ oneValueLeadingDetachedComments.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.SourceCodeInfo.Location"
        }
        override public func className() -> String {
            return "Google.Protobuf.SourceCodeInfo.Location"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:Google.Protobuf.SourceCodeInfo.Location = Google.Protobuf.SourceCodeInfo.Location()
          public func getMessage() -> Google.Protobuf.SourceCodeInfo.Location {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var path:Array<Int32> {
               get {
                   return builderResult.path
               }
               set (array) {
                   builderResult.path = array
               }
          }
          @discardableResult
          public func setPath(_ value:Array<Int32>) -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            self.path = value
            return self
          }
          @discardableResult
          public func clearPath() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
             builderResult.path.removeAll(keepingCapacity: false)
             return self
          }
          public var span:Array<Int32> {
               get {
                   return builderResult.span
               }
               set (array) {
                   builderResult.span = array
               }
          }
          @discardableResult
          public func setSpan(_ value:Array<Int32>) -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            self.span = value
            return self
          }
          @discardableResult
          public func clearSpan() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
             builderResult.span.removeAll(keepingCapacity: false)
             return self
          }
          public var hasLeadingComments:Bool {
               get {
                    return builderResult.hasLeadingComments
               }
          }
          public var leadingComments:String {
               get {
                    return builderResult.leadingComments
               }
               set (value) {
                   builderResult.hasLeadingComments = true
                   builderResult.leadingComments = value
               }
          }
          @discardableResult
          public func setLeadingComments(_ value:String) -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            self.leadingComments = value
            return self
          }
          @discardableResult
          public func clearLeadingComments() -> Google.Protobuf.SourceCodeInfo.Location.Builder{
               builderResult.hasLeadingComments = false
               builderResult.leadingComments = ""
               return self
          }
          public var hasTrailingComments:Bool {
               get {
                    return builderResult.hasTrailingComments
               }
          }
          public var trailingComments:String {
               get {
                    return builderResult.trailingComments
               }
               set (value) {
                   builderResult.hasTrailingComments = true
                   builderResult.trailingComments = value
               }
          }
          @discardableResult
          public func setTrailingComments(_ value:String) -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            self.trailingComments = value
            return self
          }
          @discardableResult
          public func clearTrailingComments() -> Google.Protobuf.SourceCodeInfo.Location.Builder{
               builderResult.hasTrailingComments = false
               builderResult.trailingComments = ""
               return self
          }
          public var leadingDetachedComments:Array<String> {
               get {
                   return builderResult.leadingDetachedComments
               }
               set (array) {
                   builderResult.leadingDetachedComments = array
               }
          }
          @discardableResult
          public func setLeadingDetachedComments(_ value:Array<String>) -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            self.leadingDetachedComments = value
            return self
          }
          @discardableResult
          public func clearLeadingDetachedComments() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
             builderResult.leadingDetachedComments.removeAll(keepingCapacity: false)
             return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            builderResult = Google.Protobuf.SourceCodeInfo.Location()
            return self
          }
          override public func clone() throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            return try Google.Protobuf.SourceCodeInfo.Location.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> Google.Protobuf.SourceCodeInfo.Location {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Google.Protobuf.SourceCodeInfo.Location {
            let returnMe:Google.Protobuf.SourceCodeInfo.Location = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:Google.Protobuf.SourceCodeInfo.Location) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            if other == Google.Protobuf.SourceCodeInfo.Location() {
             return self
            }
            if !other.path.isEmpty {
                builderResult.path += other.path
            }
            if !other.span.isEmpty {
                builderResult.span += other.span
            }
            if other.hasLeadingComments {
                 leadingComments = other.leadingComments
            }
            if other.hasTrailingComments {
                 trailingComments = other.trailingComments
            }
            if !other.leadingDetachedComments.isEmpty {
                builderResult.leadingDetachedComments += other.leadingDetachedComments
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                let length = Int(try codedInputStream.readRawVarint32())
                let limit = try codedInputStream.pushLimit(byteLimit: length)
                while (codedInputStream.bytesUntilLimit() > 0) {
                  builderResult.path.append(try codedInputStream.readInt32())
                }
                codedInputStream.popLimit(oldLimit: limit)

              case 18:
                let length = Int(try codedInputStream.readRawVarint32())
                let limit = try codedInputStream.pushLimit(byteLimit: length)
                while (codedInputStream.bytesUntilLimit() > 0) {
                  builderResult.span.append(try codedInputStream.readInt32())
                }
                codedInputStream.popLimit(oldLimit: limit)

              case 26:
                leadingComments = try codedInputStream.readString()

              case 34:
                trailingComments = try codedInputStream.readString()

              case 50:
                leadingDetachedComments += [try codedInputStream.readString()]

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            let resultDecodedBuilder = Google.Protobuf.SourceCodeInfo.Location.Builder()
            if let jsonValuePath = jsonMap["path"] as? Array<Int> {
              var jsonArrayPath:Array<Int32> = []
              for oneValuePath in jsonValuePath {
                jsonArrayPath.append(Int32(oneValuePath))
              }
              resultDecodedBuilder.path = jsonArrayPath
            }
            if let jsonValueSpan = jsonMap["span"] as? Array<Int> {
              var jsonArraySpan:Array<Int32> = []
              for oneValueSpan in jsonValueSpan {
                jsonArraySpan.append(Int32(oneValueSpan))
              }
              resultDecodedBuilder.span = jsonArraySpan
            }
            if let jsonValueLeadingComments = jsonMap["leadingComments"] as? String {
              resultDecodedBuilder.leadingComments = jsonValueLeadingComments
            }
            if let jsonValueTrailingComments = jsonMap["trailingComments"] as? String {
              resultDecodedBuilder.trailingComments = jsonValueTrailingComments
            }
            if let jsonValueLeadingDetachedComments = jsonMap["leadingDetachedComments"] as? Array<String> {
              var jsonArrayLeadingDetachedComments:Array<String> = []
              for oneValueLeadingDetachedComments in jsonValueLeadingDetachedComments {
                jsonArrayLeadingDetachedComments.append(oneValueLeadingDetachedComments)
              }
              resultDecodedBuilder.leadingDetachedComments = jsonArrayLeadingDetachedComments
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Google.Protobuf.SourceCodeInfo.Location.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end

    public fileprivate(set) var location:Array<Google.Protobuf.SourceCodeInfo.Location>  = Array<Google.Protobuf.SourceCodeInfo.Location>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      for oneElementLocation in location {
          try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementLocation)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementLocation in location {
          serialize_size += oneElementLocation.computeMessageSize(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.SourceCodeInfo.Builder {
      return Google.Protobuf.SourceCodeInfo.classBuilder() as! Google.Protobuf.SourceCodeInfo.Builder
    }
    public func getBuilder() -> Google.Protobuf.SourceCodeInfo.Builder {
      return classBuilder() as! Google.Protobuf.SourceCodeInfo.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.SourceCodeInfo.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.SourceCodeInfo.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.SourceCodeInfo.Builder {
      return try Google.Protobuf.SourceCodeInfo.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.SourceCodeInfo) throws -> Google.Protobuf.SourceCodeInfo.Builder {
      return try Google.Protobuf.SourceCodeInfo.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !location.isEmpty {
        var jsonArrayLocation:Array<Dictionary<String,Any>> = []
          for oneValueLocation in location {
            let ecodedMessageLocation = try oneValueLocation.encode()
            jsonArrayLocation.append(ecodedMessageLocation)
          }
        jsonMap["location"] = jsonArrayLocation
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.SourceCodeInfo {
      return try Google.Protobuf.SourceCodeInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.SourceCodeInfo {
      return try Google.Protobuf.SourceCodeInfo.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var locationElementIndex:Int = 0
      for oneElementLocation in location {
          output += "\(indent) location[\(locationElementIndex)] {\n"
          output += try oneElementLocation.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          locationElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementLocation in location {
                hashCode = (hashCode &* 31) &+ oneElementLocation.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.SourceCodeInfo"
    }
    override public func className() -> String {
        return "Google.Protobuf.SourceCodeInfo"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.SourceCodeInfo = Google.Protobuf.SourceCodeInfo()
      public func getMessage() -> Google.Protobuf.SourceCodeInfo {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var location:Array<Google.Protobuf.SourceCodeInfo.Location> {
           get {
               return builderResult.location
           }
           set (value) {
               builderResult.location = value
           }
      }
      @discardableResult
      public func setLocation(_ value:Array<Google.Protobuf.SourceCodeInfo.Location>) -> Google.Protobuf.SourceCodeInfo.Builder {
        self.location = value
        return self
      }
      @discardableResult
      public func clearLocation() -> Google.Protobuf.SourceCodeInfo.Builder {
        builderResult.location.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.SourceCodeInfo.Builder {
        builderResult = Google.Protobuf.SourceCodeInfo()
        return self
      }
      override public func clone() throws -> Google.Protobuf.SourceCodeInfo.Builder {
        return try Google.Protobuf.SourceCodeInfo.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.SourceCodeInfo {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.SourceCodeInfo {
        let returnMe:Google.Protobuf.SourceCodeInfo = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.SourceCodeInfo) throws -> Google.Protobuf.SourceCodeInfo.Builder {
        if other == Google.Protobuf.SourceCodeInfo() {
         return self
        }
        if !other.location.isEmpty  {
           builderResult.location += other.location
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.SourceCodeInfo.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Google.Protobuf.SourceCodeInfo.Location.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            location.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.SourceCodeInfo.Builder {
        let resultDecodedBuilder = Google.Protobuf.SourceCodeInfo.Builder()
        if let jsonValueLocation = jsonMap["location"] as? Array<Dictionary<String,Any>> {
          var jsonArrayLocation:Array<Google.Protobuf.SourceCodeInfo.Location> = []
          for oneValueLocation in jsonValueLocation {
            let messageFromStringLocation = try Google.Protobuf.SourceCodeInfo.Location.Builder.decodeToBuilder(jsonMap:oneValueLocation).build()

            jsonArrayLocation.append(messageFromStringLocation)
          }
          resultDecodedBuilder.location = jsonArrayLocation
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.SourceCodeInfo.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.SourceCodeInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // Describes the relationship between generated code and its original source
  // file. A GeneratedCodeInfo message is associated with only one generated
  // source file, but may contain references to different source .proto files.
  final public class GeneratedCodeInfo : GeneratedMessage {

    public static func == (lhs: Google.Protobuf.GeneratedCodeInfo, rhs: Google.Protobuf.GeneratedCodeInfo) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.annotation == rhs.annotation)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



    //Nested type declaration start

      final public class Annotation : GeneratedMessage {

        public static func == (lhs: Google.Protobuf.GeneratedCodeInfo.Annotation, rhs: Google.Protobuf.GeneratedCodeInfo.Annotation) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.path == rhs.path)
          fieldCheck = fieldCheck && (lhs.hasSourceFile == rhs.hasSourceFile) && (!lhs.hasSourceFile || lhs.sourceFile == rhs.sourceFile)
          fieldCheck = fieldCheck && (lhs.hasBegin == rhs.hasBegin) && (!lhs.hasBegin || lhs.begin == rhs.begin)
          fieldCheck = fieldCheck && (lhs.hasEnd == rhs.hasEnd) && (!lhs.hasEnd || lhs.end == rhs.end)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        // Identifies the element in the original source .proto file. This field
        // is formatted the same as SourceCodeInfo.Location.path.
        public fileprivate(set) var path:Array<Int32> = Array<Int32>()
        private var pathMemoizedSerializedSize:Int32 = -1
        // Identifies the filesystem path to the original source .proto.
        public fileprivate(set) var sourceFile:String = ""
        public fileprivate(set) var hasSourceFile:Bool = false

        // Identifies the starting offset in bytes in the generated code
        // that relates to the identified object.
        public fileprivate(set) var begin:Int32 = Int32(0)
        public fileprivate(set) var hasBegin:Bool = false

        // Identifies the ending offset in bytes in the generated code that
        // relates to the identified offset. The end offset should be one past
        // the last relevant byte (so the length of the text = end - begin).
        public fileprivate(set) var end:Int32 = Int32(0)
        public fileprivate(set) var hasEnd:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if !path.isEmpty {
            try codedOutputStream.writeRawVarint32(value: 10)
            try codedOutputStream.writeRawVarint32(value: pathMemoizedSerializedSize)
            for oneValuepath in path {
              try codedOutputStream.writeInt32NoTag(value: oneValuepath)
            }
          }
          if hasSourceFile {
            try codedOutputStream.writeString(fieldNumber: 2, value:sourceFile)
          }
          if hasBegin {
            try codedOutputStream.writeInt32(fieldNumber: 3, value:begin)
          }
          if hasEnd {
            try codedOutputStream.writeInt32(fieldNumber: 4, value:end)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          var dataSizePath:Int32 = 0
          for oneValuepath in path {
              dataSizePath += oneValuepath.computeInt32SizeNoTag()
          }
          serialize_size += dataSizePath
          if !path.isEmpty {
            serialize_size += 1
            serialize_size += dataSizePath.computeInt32SizeNoTag()
          }
          pathMemoizedSerializedSize = dataSizePath
          if hasSourceFile {
            serialize_size += sourceFile.computeStringSize(fieldNumber: 2)
          }
          if hasBegin {
            serialize_size += begin.computeInt32Size(fieldNumber: 3)
          }
          if hasEnd {
            serialize_size += end.computeInt32Size(fieldNumber: 4)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
          return Google.Protobuf.GeneratedCodeInfo.Annotation.classBuilder() as! Google.Protobuf.GeneratedCodeInfo.Annotation.Builder
        }
        public func getBuilder() -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
          return classBuilder() as! Google.Protobuf.GeneratedCodeInfo.Annotation.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Google.Protobuf.GeneratedCodeInfo.Annotation.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Google.Protobuf.GeneratedCodeInfo.Annotation.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
          return try Google.Protobuf.GeneratedCodeInfo.Annotation.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.GeneratedCodeInfo.Annotation) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
          return try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if !path.isEmpty {
            var jsonArrayPath:Array<Int> = []
              for oneValuePath in path {
                jsonArrayPath.append(Int(oneValuePath))
              }
            jsonMap["path"] = jsonArrayPath
          }
          if hasSourceFile {
            jsonMap["sourceFile"] = sourceFile
          }
          if hasBegin {
            jsonMap["begin"] = Int(begin)
          }
          if hasEnd {
            jsonMap["end"] = Int(end)
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation {
          return try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation {
          return try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          var pathElementIndex:Int = 0
          for oneValuePath in path  {
              output += "\(indent) path[\(pathElementIndex)]: \(oneValuePath)\n"
              pathElementIndex += 1
          }
          if hasSourceFile {
            output += "\(indent) sourceFile: \(sourceFile) \n"
          }
          if hasBegin {
            output += "\(indent) begin: \(begin) \n"
          }
          if hasEnd {
            output += "\(indent) end: \(end) \n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValuePath in path {
                    hashCode = (hashCode &* 31) &+ oneValuePath.hashValue
                }
                if hasSourceFile {
                   hashCode = (hashCode &* 31) &+ sourceFile.hashValue
                }
                if hasBegin {
                   hashCode = (hashCode &* 31) &+ begin.hashValue
                }
                if hasEnd {
                   hashCode = (hashCode &* 31) &+ end.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.GeneratedCodeInfo.Annotation"
        }
        override public func className() -> String {
            return "Google.Protobuf.GeneratedCodeInfo.Annotation"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:Google.Protobuf.GeneratedCodeInfo.Annotation = Google.Protobuf.GeneratedCodeInfo.Annotation()
          public func getMessage() -> Google.Protobuf.GeneratedCodeInfo.Annotation {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var path:Array<Int32> {
               get {
                   return builderResult.path
               }
               set (array) {
                   builderResult.path = array
               }
          }
          @discardableResult
          public func setPath(_ value:Array<Int32>) -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
            self.path = value
            return self
          }
          @discardableResult
          public func clearPath() -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
             builderResult.path.removeAll(keepingCapacity: false)
             return self
          }
          public var hasSourceFile:Bool {
               get {
                    return builderResult.hasSourceFile
               }
          }
          public var sourceFile:String {
               get {
                    return builderResult.sourceFile
               }
               set (value) {
                   builderResult.hasSourceFile = true
                   builderResult.sourceFile = value
               }
          }
          @discardableResult
          public func setSourceFile(_ value:String) -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
            self.sourceFile = value
            return self
          }
          @discardableResult
          public func clearSourceFile() -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder{
               builderResult.hasSourceFile = false
               builderResult.sourceFile = ""
               return self
          }
          public var hasBegin:Bool {
               get {
                    return builderResult.hasBegin
               }
          }
          public var begin:Int32 {
               get {
                    return builderResult.begin
               }
               set (value) {
                   builderResult.hasBegin = true
                   builderResult.begin = value
               }
          }
          @discardableResult
          public func setBegin(_ value:Int32) -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
            self.begin = value
            return self
          }
          @discardableResult
          public func clearBegin() -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder{
               builderResult.hasBegin = false
               builderResult.begin = Int32(0)
               return self
          }
          public var hasEnd:Bool {
               get {
                    return builderResult.hasEnd
               }
          }
          public var end:Int32 {
               get {
                    return builderResult.end
               }
               set (value) {
                   builderResult.hasEnd = true
                   builderResult.end = value
               }
          }
          @discardableResult
          public func setEnd(_ value:Int32) -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
            self.end = value
            return self
          }
          @discardableResult
          public func clearEnd() -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder{
               builderResult.hasEnd = false
               builderResult.end = Int32(0)
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
            builderResult = Google.Protobuf.GeneratedCodeInfo.Annotation()
            return self
          }
          override public func clone() throws -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
            return try Google.Protobuf.GeneratedCodeInfo.Annotation.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> Google.Protobuf.GeneratedCodeInfo.Annotation {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Google.Protobuf.GeneratedCodeInfo.Annotation {
            let returnMe:Google.Protobuf.GeneratedCodeInfo.Annotation = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:Google.Protobuf.GeneratedCodeInfo.Annotation) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
            if other == Google.Protobuf.GeneratedCodeInfo.Annotation() {
             return self
            }
            if !other.path.isEmpty {
                builderResult.path += other.path
            }
            if other.hasSourceFile {
                 sourceFile = other.sourceFile
            }
            if other.hasBegin {
                 begin = other.begin
            }
            if other.hasEnd {
                 end = other.end
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                let length = Int(try codedInputStream.readRawVarint32())
                let limit = try codedInputStream.pushLimit(byteLimit: length)
                while (codedInputStream.bytesUntilLimit() > 0) {
                  builderResult.path.append(try codedInputStream.readInt32())
                }
                codedInputStream.popLimit(oldLimit: limit)

              case 18:
                sourceFile = try codedInputStream.readString()

              case 24:
                begin = try codedInputStream.readInt32()

              case 32:
                end = try codedInputStream.readInt32()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
            let resultDecodedBuilder = Google.Protobuf.GeneratedCodeInfo.Annotation.Builder()
            if let jsonValuePath = jsonMap["path"] as? Array<Int> {
              var jsonArrayPath:Array<Int32> = []
              for oneValuePath in jsonValuePath {
                jsonArrayPath.append(Int32(oneValuePath))
              }
              resultDecodedBuilder.path = jsonArrayPath
            }
            if let jsonValueSourceFile = jsonMap["sourceFile"] as? String {
              resultDecodedBuilder.sourceFile = jsonValueSourceFile
            }
            if let jsonValueBegin = jsonMap["begin"] as? Int {
              resultDecodedBuilder.begin = Int32(jsonValueBegin)
            }
            if let jsonValueEnd = jsonMap["end"] as? Int {
              resultDecodedBuilder.end = Int32(jsonValueEnd)
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end

    public fileprivate(set) var annotation:Array<Google.Protobuf.GeneratedCodeInfo.Annotation>  = Array<Google.Protobuf.GeneratedCodeInfo.Annotation>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      for oneElementAnnotation in annotation {
          try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementAnnotation)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementAnnotation in annotation {
          serialize_size += oneElementAnnotation.computeMessageSize(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Google.Protobuf.GeneratedCodeInfo.Builder {
      return Google.Protobuf.GeneratedCodeInfo.classBuilder() as! Google.Protobuf.GeneratedCodeInfo.Builder
    }
    public func getBuilder() -> Google.Protobuf.GeneratedCodeInfo.Builder {
      return classBuilder() as! Google.Protobuf.GeneratedCodeInfo.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.GeneratedCodeInfo.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Google.Protobuf.GeneratedCodeInfo.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.GeneratedCodeInfo.Builder {
      return try Google.Protobuf.GeneratedCodeInfo.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Google.Protobuf.GeneratedCodeInfo) throws -> Google.Protobuf.GeneratedCodeInfo.Builder {
      return try Google.Protobuf.GeneratedCodeInfo.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !annotation.isEmpty {
        var jsonArrayAnnotation:Array<Dictionary<String,Any>> = []
          for oneValueAnnotation in annotation {
            let ecodedMessageAnnotation = try oneValueAnnotation.encode()
            jsonArrayAnnotation.append(ecodedMessageAnnotation)
          }
        jsonMap["annotation"] = jsonArrayAnnotation
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.GeneratedCodeInfo {
      return try Google.Protobuf.GeneratedCodeInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Google.Protobuf.GeneratedCodeInfo {
      return try Google.Protobuf.GeneratedCodeInfo.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var annotationElementIndex:Int = 0
      for oneElementAnnotation in annotation {
          output += "\(indent) annotation[\(annotationElementIndex)] {\n"
          output += try oneElementAnnotation.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          annotationElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementAnnotation in annotation {
                hashCode = (hashCode &* 31) &+ oneElementAnnotation.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.GeneratedCodeInfo"
    }
    override public func className() -> String {
        return "Google.Protobuf.GeneratedCodeInfo"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Google.Protobuf.GeneratedCodeInfo = Google.Protobuf.GeneratedCodeInfo()
      public func getMessage() -> Google.Protobuf.GeneratedCodeInfo {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var annotation:Array<Google.Protobuf.GeneratedCodeInfo.Annotation> {
           get {
               return builderResult.annotation
           }
           set (value) {
               builderResult.annotation = value
           }
      }
      @discardableResult
      public func setAnnotation(_ value:Array<Google.Protobuf.GeneratedCodeInfo.Annotation>) -> Google.Protobuf.GeneratedCodeInfo.Builder {
        self.annotation = value
        return self
      }
      @discardableResult
      public func clearAnnotation() -> Google.Protobuf.GeneratedCodeInfo.Builder {
        builderResult.annotation.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Google.Protobuf.GeneratedCodeInfo.Builder {
        builderResult = Google.Protobuf.GeneratedCodeInfo()
        return self
      }
      override public func clone() throws -> Google.Protobuf.GeneratedCodeInfo.Builder {
        return try Google.Protobuf.GeneratedCodeInfo.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Google.Protobuf.GeneratedCodeInfo {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.GeneratedCodeInfo {
        let returnMe:Google.Protobuf.GeneratedCodeInfo = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Google.Protobuf.GeneratedCodeInfo) throws -> Google.Protobuf.GeneratedCodeInfo.Builder {
        if other == Google.Protobuf.GeneratedCodeInfo() {
         return self
        }
        if !other.annotation.isEmpty  {
           builderResult.annotation += other.annotation
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.GeneratedCodeInfo.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.GeneratedCodeInfo.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Google.Protobuf.GeneratedCodeInfo.Annotation.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            annotation.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.GeneratedCodeInfo.Builder {
        let resultDecodedBuilder = Google.Protobuf.GeneratedCodeInfo.Builder()
        if let jsonValueAnnotation = jsonMap["annotation"] as? Array<Dictionary<String,Any>> {
          var jsonArrayAnnotation:Array<Google.Protobuf.GeneratedCodeInfo.Annotation> = []
          for oneValueAnnotation in jsonValueAnnotation {
            let messageFromStringAnnotation = try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder.decodeToBuilder(jsonMap:oneValueAnnotation).build()

            jsonArrayAnnotation.append(messageFromStringAnnotation)
          }
          resultDecodedBuilder.annotation = jsonArrayAnnotation
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.GeneratedCodeInfo.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.GeneratedCodeInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

}
extension Google.Protobuf.FileDescriptorSet: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.FileDescriptorSet> {
    var mergedArray = Array<Google.Protobuf.FileDescriptorSet>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.FileDescriptorSet? {
    return try Google.Protobuf.FileDescriptorSet.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.FileDescriptorSet {
    return try Google.Protobuf.FileDescriptorSet.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorSet {
    return try Google.Protobuf.FileDescriptorSet.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.FileDescriptorSet {
    return try Google.Protobuf.FileDescriptorSet.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorSet {
    return try Google.Protobuf.FileDescriptorSet.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.FileDescriptorSet {
    return try Google.Protobuf.FileDescriptorSet.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorSet {
    return try Google.Protobuf.FileDescriptorSet.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.FileDescriptorProto: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.FileDescriptorProto> {
    var mergedArray = Array<Google.Protobuf.FileDescriptorProto>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.FileDescriptorProto? {
    return try Google.Protobuf.FileDescriptorProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.FileDescriptorProto {
    return try Google.Protobuf.FileDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorProto {
    return try Google.Protobuf.FileDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.FileDescriptorProto {
    return try Google.Protobuf.FileDescriptorProto.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorProto {
    return try Google.Protobuf.FileDescriptorProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.FileDescriptorProto {
    return try Google.Protobuf.FileDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorProto {
    return try Google.Protobuf.FileDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.DescriptorProto: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.DescriptorProto> {
    var mergedArray = Array<Google.Protobuf.DescriptorProto>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.DescriptorProto? {
    return try Google.Protobuf.DescriptorProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.DescriptorProto {
    return try Google.Protobuf.DescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto {
    return try Google.Protobuf.DescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.DescriptorProto {
    return try Google.Protobuf.DescriptorProto.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto {
    return try Google.Protobuf.DescriptorProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.DescriptorProto {
    return try Google.Protobuf.DescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto {
    return try Google.Protobuf.DescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.DescriptorProto.ExtensionRange: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.DescriptorProto.ExtensionRange> {
    var mergedArray = Array<Google.Protobuf.DescriptorProto.ExtensionRange>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.DescriptorProto.ExtensionRange? {
    return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
    return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
    return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
    return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
    return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
    return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
    return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.DescriptorProto.ReservedRange: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.DescriptorProto.ReservedRange> {
    var mergedArray = Array<Google.Protobuf.DescriptorProto.ReservedRange>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.DescriptorProto.ReservedRange? {
    return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
    return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
    return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
    return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
    return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
    return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
    return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.FieldDescriptorProto: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.FieldDescriptorProto> {
    var mergedArray = Array<Google.Protobuf.FieldDescriptorProto>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.FieldDescriptorProto? {
    return try Google.Protobuf.FieldDescriptorProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.FieldDescriptorProto {
    return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldDescriptorProto {
    return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.FieldDescriptorProto {
    return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldDescriptorProto {
    return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.FieldDescriptorProto {
    return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldDescriptorProto {
    return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.OneofDescriptorProto: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.OneofDescriptorProto> {
    var mergedArray = Array<Google.Protobuf.OneofDescriptorProto>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.OneofDescriptorProto? {
    return try Google.Protobuf.OneofDescriptorProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.OneofDescriptorProto {
    return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofDescriptorProto {
    return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.OneofDescriptorProto {
    return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofDescriptorProto {
    return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.OneofDescriptorProto {
    return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofDescriptorProto {
    return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.EnumDescriptorProto: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.EnumDescriptorProto> {
    var mergedArray = Array<Google.Protobuf.EnumDescriptorProto>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.EnumDescriptorProto? {
    return try Google.Protobuf.EnumDescriptorProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.EnumDescriptorProto {
    return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumDescriptorProto {
    return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.EnumDescriptorProto {
    return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumDescriptorProto {
    return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.EnumDescriptorProto {
    return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumDescriptorProto {
    return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.EnumValueDescriptorProto: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.EnumValueDescriptorProto> {
    var mergedArray = Array<Google.Protobuf.EnumValueDescriptorProto>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.EnumValueDescriptorProto? {
    return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.EnumValueDescriptorProto {
    return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueDescriptorProto {
    return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.EnumValueDescriptorProto {
    return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueDescriptorProto {
    return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.EnumValueDescriptorProto {
    return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueDescriptorProto {
    return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.ServiceDescriptorProto: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.ServiceDescriptorProto> {
    var mergedArray = Array<Google.Protobuf.ServiceDescriptorProto>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.ServiceDescriptorProto? {
    return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.ServiceDescriptorProto {
    return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceDescriptorProto {
    return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.ServiceDescriptorProto {
    return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceDescriptorProto {
    return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.ServiceDescriptorProto {
    return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceDescriptorProto {
    return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.MethodDescriptorProto: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.MethodDescriptorProto> {
    var mergedArray = Array<Google.Protobuf.MethodDescriptorProto>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.MethodDescriptorProto? {
    return try Google.Protobuf.MethodDescriptorProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.MethodDescriptorProto {
    return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodDescriptorProto {
    return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.MethodDescriptorProto {
    return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodDescriptorProto {
    return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.MethodDescriptorProto {
    return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodDescriptorProto {
    return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.FileOptions: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.FileOptions> {
    var mergedArray = Array<Google.Protobuf.FileOptions>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.FileOptions? {
    return try Google.Protobuf.FileOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.FileOptions {
    return try Google.Protobuf.FileOptions.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileOptions {
    return try Google.Protobuf.FileOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.FileOptions {
    return try Google.Protobuf.FileOptions.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileOptions {
    return try Google.Protobuf.FileOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.FileOptions {
    return try Google.Protobuf.FileOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileOptions {
    return try Google.Protobuf.FileOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.MessageOptions: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.MessageOptions> {
    var mergedArray = Array<Google.Protobuf.MessageOptions>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.MessageOptions? {
    return try Google.Protobuf.MessageOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.MessageOptions {
    return try Google.Protobuf.MessageOptions.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MessageOptions {
    return try Google.Protobuf.MessageOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.MessageOptions {
    return try Google.Protobuf.MessageOptions.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MessageOptions {
    return try Google.Protobuf.MessageOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.MessageOptions {
    return try Google.Protobuf.MessageOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MessageOptions {
    return try Google.Protobuf.MessageOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.FieldOptions: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.FieldOptions> {
    var mergedArray = Array<Google.Protobuf.FieldOptions>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.FieldOptions? {
    return try Google.Protobuf.FieldOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.FieldOptions {
    return try Google.Protobuf.FieldOptions.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldOptions {
    return try Google.Protobuf.FieldOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.FieldOptions {
    return try Google.Protobuf.FieldOptions.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldOptions {
    return try Google.Protobuf.FieldOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.FieldOptions {
    return try Google.Protobuf.FieldOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldOptions {
    return try Google.Protobuf.FieldOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.OneofOptions: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.OneofOptions> {
    var mergedArray = Array<Google.Protobuf.OneofOptions>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.OneofOptions? {
    return try Google.Protobuf.OneofOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.OneofOptions {
    return try Google.Protobuf.OneofOptions.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofOptions {
    return try Google.Protobuf.OneofOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.OneofOptions {
    return try Google.Protobuf.OneofOptions.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofOptions {
    return try Google.Protobuf.OneofOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.OneofOptions {
    return try Google.Protobuf.OneofOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofOptions {
    return try Google.Protobuf.OneofOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.EnumOptions: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.EnumOptions> {
    var mergedArray = Array<Google.Protobuf.EnumOptions>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.EnumOptions? {
    return try Google.Protobuf.EnumOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.EnumOptions {
    return try Google.Protobuf.EnumOptions.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumOptions {
    return try Google.Protobuf.EnumOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.EnumOptions {
    return try Google.Protobuf.EnumOptions.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumOptions {
    return try Google.Protobuf.EnumOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.EnumOptions {
    return try Google.Protobuf.EnumOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumOptions {
    return try Google.Protobuf.EnumOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.EnumValueOptions: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.EnumValueOptions> {
    var mergedArray = Array<Google.Protobuf.EnumValueOptions>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.EnumValueOptions? {
    return try Google.Protobuf.EnumValueOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.EnumValueOptions {
    return try Google.Protobuf.EnumValueOptions.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueOptions {
    return try Google.Protobuf.EnumValueOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.EnumValueOptions {
    return try Google.Protobuf.EnumValueOptions.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueOptions {
    return try Google.Protobuf.EnumValueOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.EnumValueOptions {
    return try Google.Protobuf.EnumValueOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueOptions {
    return try Google.Protobuf.EnumValueOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.ServiceOptions: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.ServiceOptions> {
    var mergedArray = Array<Google.Protobuf.ServiceOptions>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.ServiceOptions? {
    return try Google.Protobuf.ServiceOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.ServiceOptions {
    return try Google.Protobuf.ServiceOptions.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceOptions {
    return try Google.Protobuf.ServiceOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.ServiceOptions {
    return try Google.Protobuf.ServiceOptions.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceOptions {
    return try Google.Protobuf.ServiceOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.ServiceOptions {
    return try Google.Protobuf.ServiceOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceOptions {
    return try Google.Protobuf.ServiceOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.MethodOptions: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.MethodOptions> {
    var mergedArray = Array<Google.Protobuf.MethodOptions>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.MethodOptions? {
    return try Google.Protobuf.MethodOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.MethodOptions {
    return try Google.Protobuf.MethodOptions.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodOptions {
    return try Google.Protobuf.MethodOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.MethodOptions {
    return try Google.Protobuf.MethodOptions.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodOptions {
    return try Google.Protobuf.MethodOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.MethodOptions {
    return try Google.Protobuf.MethodOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodOptions {
    return try Google.Protobuf.MethodOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.UninterpretedOption: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.UninterpretedOption> {
    var mergedArray = Array<Google.Protobuf.UninterpretedOption>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.UninterpretedOption? {
    return try Google.Protobuf.UninterpretedOption.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.UninterpretedOption {
    return try Google.Protobuf.UninterpretedOption.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption {
    return try Google.Protobuf.UninterpretedOption.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.UninterpretedOption {
    return try Google.Protobuf.UninterpretedOption.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption {
    return try Google.Protobuf.UninterpretedOption.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.UninterpretedOption {
    return try Google.Protobuf.UninterpretedOption.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption {
    return try Google.Protobuf.UninterpretedOption.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.UninterpretedOption.NamePart: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.UninterpretedOption.NamePart> {
    var mergedArray = Array<Google.Protobuf.UninterpretedOption.NamePart>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.UninterpretedOption.NamePart? {
    return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.UninterpretedOption.NamePart {
    return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption.NamePart {
    return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.UninterpretedOption.NamePart {
    return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption.NamePart {
    return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.UninterpretedOption.NamePart {
    return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption.NamePart {
    return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.SourceCodeInfo: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.SourceCodeInfo> {
    var mergedArray = Array<Google.Protobuf.SourceCodeInfo>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.SourceCodeInfo? {
    return try Google.Protobuf.SourceCodeInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.SourceCodeInfo {
    return try Google.Protobuf.SourceCodeInfo.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo {
    return try Google.Protobuf.SourceCodeInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.SourceCodeInfo {
    return try Google.Protobuf.SourceCodeInfo.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo {
    return try Google.Protobuf.SourceCodeInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.SourceCodeInfo {
    return try Google.Protobuf.SourceCodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo {
    return try Google.Protobuf.SourceCodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.SourceCodeInfo.Location: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.SourceCodeInfo.Location> {
    var mergedArray = Array<Google.Protobuf.SourceCodeInfo.Location>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.SourceCodeInfo.Location? {
    return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.SourceCodeInfo.Location {
    return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo.Location {
    return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.SourceCodeInfo.Location {
    return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo.Location {
    return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.SourceCodeInfo.Location {
    return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo.Location {
    return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.GeneratedCodeInfo: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.GeneratedCodeInfo> {
    var mergedArray = Array<Google.Protobuf.GeneratedCodeInfo>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.GeneratedCodeInfo? {
    return try Google.Protobuf.GeneratedCodeInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.GeneratedCodeInfo {
    return try Google.Protobuf.GeneratedCodeInfo.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.GeneratedCodeInfo {
    return try Google.Protobuf.GeneratedCodeInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.GeneratedCodeInfo {
    return try Google.Protobuf.GeneratedCodeInfo.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.GeneratedCodeInfo {
    return try Google.Protobuf.GeneratedCodeInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.GeneratedCodeInfo {
    return try Google.Protobuf.GeneratedCodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.GeneratedCodeInfo {
    return try Google.Protobuf.GeneratedCodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Google.Protobuf.GeneratedCodeInfo.Annotation: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.GeneratedCodeInfo.Annotation> {
    var mergedArray = Array<Google.Protobuf.GeneratedCodeInfo.Annotation>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation? {
    return try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation {
    return try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.DescriptorRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation {
    return try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation {
    return try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation {
    return try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation {
    return try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.GeneratedCodeInfo.Annotation {
    return try Google.Protobuf.GeneratedCodeInfo.Annotation.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}

// @@protoc_insertion_point(global_scope)
